<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HonQi&#39;s Letter</title>
  
  <subtitle>记录一些学习心得和笔记的地方</subtitle>
  <link href="https://notes.honqi.ink/atom.xml" rel="self"/>
  
  <link href="https://notes.honqi.ink/"/>
  <updated>2020-05-04T16:00:00.000Z</updated>
  <id>https://notes.honqi.ink/</id>
  
  <author>
    <name>HonQi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 动画语法糖 -- ShadowPlay</title>
    <link href="https://notes.honqi.ink/2020/05/04/Cocoa/Swift/shadowplay/"/>
    <id>https://notes.honqi.ink/2020/05/04/Cocoa/Swift/shadowplay/</id>
    <published>2020-05-04T16:00:00.000Z</published>
    <updated>2020-05-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./shadowplay/shadowplay.jpg" alt="Shadow play"></p><span id="more"></span><h2 id="重复造轮子动机"><a href="#重复造轮子动机" class="headerlink" title="重复造轮子动机"></a>重复造轮子动机</h2><p>iOS 上的动画一直以优雅、美观著称，让人看起来觉得自然，感觉舒服。但是写起来就有点一言难尽了，尤其是涉及比较复杂的动画时，动不动就要对一堆属性赋值，每次写完之后都是一大坨代码；对比前端一行可以描述基本的动画属性的语法(<code>transition: width 2s, height 2s, background-color 2s, transform 2s;</code>)，就更加显得啰嗦。基于此原因，利用 Swift 枚举的强大特性对动画进行了简单的封装，让它写起来稍微简单一些。</p><p>其实 iOS 上已经有很多动画库了，但是它们有些是高度封装的动画，适用场景比较窄。也有很多链式的动画，写完之后很长的一串，在语法上没有太强的逻辑性；所以我决定写一个符合自己逻辑习惯的</p><h2 id="Shadow-Play-的含义"><a href="#Shadow-Play-的含义" class="headerlink" title="Shadow Play 的含义"></a>Shadow Play 的含义</h2><p>皮影戏（Shadow Play）是让观众通过白色幕布，观看一种平面人偶表演的灯影来达到艺术效果的戏剧形式。而动画是静止的画面以一定速度连续播放时，肉眼因视觉残像产生的错觉；二者是有一定的相似性的。每次写动画，我都感觉自己不是一个码农，而是一个皮影艺人，先精心的绘制一个精美的皮影，然后操纵它动起来</p><h2 id="Shadow-Play-结构"><a href="#Shadow-Play-结构" class="headerlink" title="Shadow Play 结构"></a>Shadow Play 结构</h2><p>废话半天，终于进入正题，简单介绍下 ShadowPlay：利用 Swift 的枚举特性将动画的属性变量保存起来，然后再转换为具体的 <code>CAAnimation</code> 对象。</p><p><img src="./shadowplay/shadowplay_structure.png" alt="structure"></p><ul><li>Engine: <code>Engine</code> 存储多个 <code>Animation Node</code>，在开启动画之后将每个 <code>Animation Node</code> 转为对应的 <code>CAAnimation</code> 对象并添加到 <code>CALayer</code> 上，同时作为 <code>CAAnimation</code> 对象的动画代理，在动画的代理回调中触发对应的回调，以及开启下一个动画</li><li>Animation Node: 通过枚举值参数的方式生成基本的动画类型，之后将根据枚举的类型和对应的属性生成 <code>CAAnimation</code> 对象。其中以 <code>basic</code>、<code>spring</code>、<code>keyframe</code>、<code>transition</code>、<code>group</code>几个值为基础，对应 iOS 中的同名动画类，其余的每个枚举值都会被转为这几个类型</li><li>Animation Options: 同样通过枚举参数的形式存储动画的属性；例如 <code>CAMediaTiming</code> 协议中的属性。在将 <code>Animation Node</code> 转为 <code>CAAnimation</code> 对象时将这些属性注入到 <code>CAAnimation</code> 中，以此来完成属性的赋值，同时也将动画的创建和属性赋值区分开来</li><li>Animation Callback: <code>CAAnimationDelegate</code> 的简单包装，可以添加每个 <code>Node</code> 动画开始和完成后的回调</li></ul><h2 id="链式语法设置动画属性及回调"><a href="#链式语法设置动画属性及回调" class="headerlink" title="链式语法设置动画属性及回调"></a>链式语法设置动画属性及回调</h2><p>ShadowPlay 同样支持链式语法设置动画属性和回调，只需要对 <code>AnimationNode</code> 不停的调用 <code>options &amp; callback</code> 即可多次设置，也可以一次设置多个属性。</p><p><code>AnimationNode</code> 是一个 <code>indirect</code> 枚举，其中有一个临时保存动画的类型 <code>case animation(_ animation: AnimationNode, options: AnimationOptions = [], callbacks: AnimationCallbacks = [])</code> ，当对 <code>AnimationNode</code> 多个设置属性的时候，会将当前的 <code>AnimationNode</code> 存储到该类型中，通过它保存额外的属性以及回调，这样可以保证语法的简洁和统一</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>移动 <code>X</code> 坐标动画</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        AnimationEngine(with: view.layer).series(</span></span><br><span class="line"><span class="comment">//            AnimationNode.moveX(100)</span></span><br><span class="line"><span class="comment">//                .options(</span></span><br><span class="line"><span class="comment">//                    AnimationOption.duration(2),</span></span><br><span class="line"><span class="comment">//                    AnimationOption.additive(true)</span></span><br><span class="line"><span class="comment">//            )</span></span><br><span class="line"><span class="comment">//                .options(</span></span><br><span class="line"><span class="comment">//                    AnimationOption.beginTime(0.3),</span></span><br><span class="line"><span class="comment">//                    AnimationOption.autoReverses(false)</span></span><br><span class="line"><span class="comment">//            )</span></span><br><span class="line"><span class="comment">//                .callbacks(</span></span><br><span class="line"><span class="comment">//                    AnimationCallback.start(&#123; (_) in</span></span><br><span class="line"><span class="comment">//                        print(&quot;Animation start&quot;)</span></span><br><span class="line"><span class="comment">//                    &#125;),</span></span><br><span class="line"><span class="comment">//                    AnimationCallback.stop(&#123; (_, isStop) in</span></span><br><span class="line"><span class="comment">//                        print(&quot;Animation is \(isStop)&quot;)</span></span><br><span class="line"><span class="comment">//                    &#125;)</span></span><br><span class="line"><span class="comment">//            )</span></span><br><span class="line"><span class="comment">//        ).run()</span></span><br><span class="line"></span><br><span class="line">view.layer.sp.series(</span><br><span class="line">            .moveX(<span class="number">100</span>)</span><br><span class="line">                .options(</span><br><span class="line">                    .duration(<span class="number">2</span>),</span><br><span class="line">                    .additive(<span class="literal">true</span>),</span><br><span class="line">                    .beginTime(<span class="number">0.3</span>),</span><br><span class="line">                    .autoReverses(<span class="literal">false</span>)</span><br><span class="line">            )</span><br><span class="line">                .callbacks(</span><br><span class="line">                    .start(&#123; (<span class="keyword">_</span>) <span class="keyword">in</span></span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;Animation start&quot;</span>)</span><br><span class="line">                    &#125;),</span><br><span class="line">                    .stop(&#123; (<span class="keyword">_</span>, isStop) <span class="keyword">in</span></span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;Animation is <span class="subst">\(isStop)</span>&quot;</span>)</span><br><span class="line">                    &#125;)</span><br><span class="line">            )</span><br><span class="line">        ).run()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;./shadowplay/shadowplay.jpg&quot; alt=&quot;Shadow play&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Swift" scheme="https://notes.honqi.ink/categories/swift/"/>
    
    <category term="Animation" scheme="https://notes.honqi.ink/categories/swift/animation/"/>
    
    
  </entry>
  
  <entry>
    <title>OC 严格枚举</title>
    <link href="https://notes.honqi.ink/2019/06/19/Cocoa/ObjC/OC%E4%B8%A5%E6%A0%BC%E6%9E%9A%E4%B8%BE/"/>
    <id>https://notes.honqi.ink/2019/06/19/Cocoa/ObjC/OC%E4%B8%A5%E6%A0%BC%E6%9E%9A%E4%B8%BE/</id>
    <published>2019-06-19T16:00:00.000Z</published>
    <updated>2019-06-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们在使用枚举时会使用 <code>default</code> 处理所有额外的case，防止遇到没有枚举情况导致崩溃。有一些编程规范会建议列举出所有的 <em>case</em>，避免枚举成员增加之后忘记没有随之增加新的 <em>case</em> 处理逻辑导致的 bug，通常这种 bug 也不太容易发现。为了避免某些重要的枚举漏掉处理 <em>case</em>，我们可以使用宏和编译特性保证这一点</p><span id="more"></span><h2 id="正常的枚举"><a href="#正常的枚举" class="headerlink" title="正常的枚举"></a>正常的枚举</h2><p>我们从一个简单的枚举使用例子开始</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> : <span class="built_in">NSUInteger</span> &#123;</span><br><span class="line">    EnumCaseA,</span><br><span class="line">    EnumCaseB,</span><br><span class="line">    EnumCaseC,</span><br><span class="line">    EnumCaseD</span><br><span class="line">&#125; EnumCase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> useEnumDefault() &#123;</span><br><span class="line">    EnumCase val = EnumCaseA;</span><br><span class="line">    <span class="keyword">switch</span> (val) &#123;</span><br><span class="line">        <span class="keyword">case</span> EnumCaseA:</span><br><span class="line">            <span class="comment">// EnumCaseA handler</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EnumCaseB:</span><br><span class="line">            <span class="comment">// EnumCaseB handler</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用了 <code>default</code>，即使我们没有列举出剩下的 <code>EnumCaseC &amp; EnumCaseD</code> 也没有任何问题；当然，再在枚举中增加一个 <code>EnumCaseE</code> 依然不会有错误。</p><p>但是如果这样的枚举使用的位置很多，而新的 <code>EnumCaseE</code> 需要单独的处理逻辑的话，就很容易漏掉对其中某一个 <code>EnumCaseE</code> 的处理，编译器也不会给你任何的信息提示</p><h2 id="Wswitch-enum-编译检查"><a href="#Wswitch-enum-编译检查" class="headerlink" title="-Wswitch-enum 编译检查"></a>-Wswitch-enum 编译检查</h2><p>在 GCC 文档中找到一个编译检查项符合要求；当开启这个编译检查时，必须列出所有的枚举 <code>case</code>，否则就会出现错误。即使用了 <code>default</code> 也不行</p><p>当在 Xcode 中添加这个编译选项之后，可能会发现一串的错误。因为在 Xcode 中开启意味着所有的枚举都要遵守这个规则。但我们只是想要某些重要的枚举才需要这样的检查</p><h2 id="clang-diagnostic"><a href="#clang-diagnostic" class="headerlink" title="clang diagnostic"></a>clang diagnostic</h2><p>Clang diagnostic 是 Clang 编译时的一个检查上下文声明；相信很多人都用来关闭过一些警告：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wunused-variable&quot;</span>  </span></span><br><span class="line">    <span class="built_in">NSInteger</span> val = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br></pre></td></tr></table></figure><p>它的原理是 Clang 在检查时会开启一个上下文，上下文中是全局的检查配置参数；所有的警告和错误都是通过这些参数来指定的。</p><p>如果你需要在某个代码块时使用一些临时的检查配置，那么就可以使用 <code>#pragma clang diagnostic push</code> 开启一个新的上下文，然后通过 <code>#pragma clang diagnostic pop</code> 关闭这个上下文。</p><p>期间可以通过 <code>#pragma clang diagnostic (ignored|note|error|...)</code> 声明一些新的配置</p><h2 id="严格枚举实现"><a href="#严格枚举实现" class="headerlink" title="严格枚举实现"></a>严格枚举实现</h2><p>基于上面的背景知识，我们可以通过宏定义一个严格的枚举</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRICT_SWITCH_BEGIN(val) \</span></span><br><span class="line">_Pragma(<span class="string">&quot;clang diagnostic push&quot;</span>) \</span><br><span class="line">_Pragma(<span class="string">&quot;clang diagnostic error \&quot;-Wswitch-enum\&quot;&quot;</span>) \</span><br><span class="line"><span class="keyword">switch</span>(val) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRICT_SWITCH_END \</span></span><br><span class="line">&#125; \</span><br><span class="line">_Pragma(<span class="string">&quot;clang diagnostic pop&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>由于宏不能嵌套，所以这儿需要使用 <code>_Pragma()</code> 代替 <code>#pragma</code></p></blockquote><p>然后我们再来看看使用效果</p><p><img src="./OC%E4%B8%A5%E6%A0%BC%E6%9E%9A%E4%B8%BE/oc_enum.png" alt="oc strict enum"></p><p>大功告成，编译器错误并且提示 <code>EnumCaseC &amp; EnumCaseD</code> 没有被处理</p><h2 id="额外"><a href="#额外" class="headerlink" title="额外"></a>额外</h2><p>可能有小伙伴会问：如果好几个 <code>case</code> 要用同一段逻辑，难道也要写好几遍吗？是～也不是，如果有共同的逻辑的话，还是需要将所有 <code>case</code> 全部列举出来，但是可以利用 <code>switch</code> 的穿透，使多个 <code>case</code> 执行同一段逻辑</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> useStrictDefault() &#123;</span><br><span class="line">    EnumCase val = EnumCaseA;</span><br><span class="line">    STRICT_SWITCH_BEGIN(val)</span><br><span class="line">    <span class="keyword">case</span> EnumCaseA:</span><br><span class="line">        <span class="comment">// EnumCaseA handler</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EnumCaseB:</span><br><span class="line">        <span class="comment">// EnumCaseB handler</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EnumCaseC:</span><br><span class="line">    <span class="keyword">case</span> EnumCaseD:</span><br><span class="line">        <span class="comment">// Common handler</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    STRICT_SWITCH_END</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EnumCaseC &amp; EnumCaseD</code> 共用了一段处理逻辑，</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html">GCC 编译警告</a></p><p><a href="https://clang.llvm.org/docs/UsersManual.html#diagnostic-mappings">Clang</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通常我们在使用枚举时会使用 &lt;code&gt;default&lt;/code&gt; 处理所有额外的case，防止遇到没有枚举情况导致崩溃。有一些编程规范会建议列举出所有的 &lt;em&gt;case&lt;/em&gt;，避免枚举成员增加之后忘记没有随之增加新的 &lt;em&gt;case&lt;/em&gt; 处理逻辑导致的 bug，通常这种 bug 也不太容易发现。为了避免某些重要的枚举漏掉处理 &lt;em&gt;case&lt;/em&gt;，我们可以使用宏和编译特性保证这一点&lt;/p&gt;</summary>
    
    
    
    <category term="__attribute__" scheme="https://notes.honqi.ink/categories/attribute/"/>
    
    <category term="ObjC" scheme="https://notes.honqi.ink/categories/attribute/objc/"/>
    
    
  </entry>
  
  <entry>
    <title>OC 中 Protocol 默认实现</title>
    <link href="https://notes.honqi.ink/2019/04/21/Cocoa/ObjC/OC%E4%B8%AD%E7%9A%84Protocol%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0/"/>
    <id>https://notes.honqi.ink/2019/04/21/Cocoa/ObjC/OC%E4%B8%AD%E7%9A%84Protocol%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-04-21T16:00:00.000Z</published>
    <updated>2019-04-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Swift 中的协议可以在 <code>Extension</code> 里面添加默认实现。这个强大的功能使用过之后就一直觉得 OC 中的协议用起来不开心了；由俭入奢易，由奢入俭难呐～ 不过没关系，其实我们可以在 OC 中实现类似的功能</p><span id="more"></span><h2 id="从-Category-说起"><a href="#从-Category-说起" class="headerlink" title="从 Category 说起"></a>从 Category 说起</h2><p>Swift 中通过协议的 <code>Extension</code> 来添加默认实现。OC 中虽然不能直接对协议添加 <code>Category</code>，但是我们也可以朝着这个方向上思考。通过 <a href="./Category%20%E5%8E%9F%E7%90%86.md"><code>Category</code> 的原理</a>可知：一个类的 <code>Category</code> 会被编译器编译，然后在 Runtime 初始化时注入到相关的类中。我们可以模拟这一个过程来实现对协议增加分类</p><p>模拟 <code>Category</code> 增加默认协议实现的流程：</p><ol><li>创造一个类继承并实现协议的方法和属性 –&gt; 模拟 <code>Category</code> 结构体用于编译时保存信息</li><li>在 Runtime 初始化时将该类中的方法和属性注入到遵守协议的类中 –&gt; 模拟 <code>Category</code> 方法和属性等注入</li></ol><h2 id="创建协议默认实现类"><a href="#创建协议默认实现类" class="headerlink" title="创建协议默认实现类"></a>创建协议默认实现类</h2><p>先创建一个类实现默认的协议；我们有如下几个需求：</p><ul><li>由于会有多个协议，需要多个类与之对应，否则协议中有相同定义的方法就会出现问题。所以类名不能重复</li><li>该类要有特殊的标识，以便我们在 Runtime 初始化时能将它与对应的协议联系起来</li><li>要能自由添加方法实现对应的协议，同时做到写起来如 Swift 般简单快捷</li></ul><p>在 OC 中，满足上诉需求的最佳解决方案就是<strong>宏</strong>：宏是一种预处理指令，它提供了一种机制，可以用来替换源代码中的字符串；不重复的类名也可以通过宏的字符串拼接实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Extension(PROTOCOL) \</span></span><br><span class="line">interface PROTOCOL ## ProtocolDefaultClass : <span class="built_in">NSObject</span> &lt; PROTOCOL &gt; &#123;&#125; \</span><br><span class="line"><span class="keyword">@end</span> \</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PROTOCOL</span> ## <span class="title">ProtocolDefaultClass</span></span></span><br></pre></td></tr></table></figure><p>当 <code>Extension</code> 宏展开之后就是一个普通的类定义代码，同时还遵守了对应的协议，只需要在宏之后添加对应的方法实现即可</p><h2 id="Runtime-注入"><a href="#Runtime-注入" class="headerlink" title="Runtime 注入"></a>Runtime 注入</h2><p>第二个困难点在于，如何能在 Runtime 初始化时将协议对应的类的方法注入到遵守协议的类中？</p><p>这个部分我们需要借助编译指令来实现，<a href="./attribute%20%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4.md"><code>__attribute__((constructor))</code></a> 构造器声明可以声明一个函数在可执行文件（或 shared library）load 时被调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> objc_protocol_default_methods_inject(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// 注入方法到遵守协议的类中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>发现了一个库（<a href="https://github.com/jspahrsummers/libextobjc">extobjc</a>）已经实现了这个功能，不重复造轮子了 。。。。。。</p><p>来解析一下它的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> concreteprotocol(NAME) \</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * create a class used to contain all the methods used in this protocol</span></span><br><span class="line"><span class="comment">     */</span> \</span><br><span class="line">    interface NAME ## _ProtocolMethodContainer : <span class="built_in">NSObject</span> &lt; NAME &gt; &#123;&#125; \</span><br><span class="line">    <span class="keyword">@end</span> \</span><br><span class="line">    \</span><br><span class="line">    <span class="class"><span class="keyword">@implementation</span> <span class="title">NAME</span> ## <span class="title">_ProtocolMethodContainer</span> \</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * when this class is loaded into the runtime, add the concrete protocol</span></span><br><span class="line"><span class="comment">     * into the list we have of them</span></span><br><span class="line"><span class="comment">     */</span> \</span><br><span class="line">    + (<span class="keyword">void</span>)load &#123; \</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * passes the actual protocol as the first parameter, then this class as</span></span><br><span class="line"><span class="comment">         * the second</span></span><br><span class="line"><span class="comment">         */</span> \</span><br><span class="line">        <span class="keyword">if</span> (!ext_addConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME)), <span class="keyword">self</span>)) \</span><br><span class="line">            fprintf(stderr, <span class="string">&quot;ERROR: Could not load concrete protocol %s\n&quot;</span>, metamacro_stringify(NAME)); \</span><br><span class="line">    &#125; \</span><br><span class="line">    \</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * using the &quot;constructor&quot; function attribute, we can ensure that this</span></span><br><span class="line"><span class="comment">     * function is executed only AFTER all the Objective-C runtime setup (i.e.,</span></span><br><span class="line"><span class="comment">     * after all +load methods have been executed)</span></span><br><span class="line"><span class="comment">     */</span> \</span><br><span class="line">    __attribute__((constructor)) \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> ext_ ## NAME ## _inject (<span class="keyword">void</span>) &#123; \</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * use this injection point to mark this concrete protocol as ready for</span></span><br><span class="line"><span class="comment">         * loading</span></span><br><span class="line"><span class="comment">         */</span> \</span><br><span class="line">        ext_loadConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME))); \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在宏定义的时候创建对应的注入方法；同时在默认实现类的 <code>+ (void)load</code> 方法中将 Protocol 以及对应的默认实现类的注入 Block 封装在起来缓存到一个全局数组中</p><p>我之前的想法是在 Runtime 初始化完成之后遍历所有的类，找到其中按照<strong>特殊规则命名</strong>的即是协议默认实现类，进一步拿到对应的协议；然后再将类中的方法同步到遵守协议的类中</p><ul><li>对比两种方案，extobjc 将协议及对应注入 Block 存储在全局数组中，在处理协议继承的情况时更加方便；同时通过对全局变量加锁可以包装线程安全</li></ul><blockquote><p><code>__attribute__((constructor))</code> 声明的方法会在 Runtime 初始化完成之后调用，所以会在 <code>+(void)load</code> 之后执行</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Swift 中的协议可以在 &lt;code&gt;Extension&lt;/code&gt; 里面添加默认实现。这个强大的功能使用过之后就一直觉得 OC 中的协议用起来不开心了；由俭入奢易，由奢入俭难呐～ 不过没关系，其实我们可以在 OC 中实现类似的功能&lt;/p&gt;</summary>
    
    
    
    <category term="Runtime" scheme="https://notes.honqi.ink/categories/runtime/"/>
    
    <category term="ObjC" scheme="https://notes.honqi.ink/categories/runtime/objc/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 模块化</title>
    <link href="https://notes.honqi.ink/2019/02/16/Cocoa/iOS/iOS%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>https://notes.honqi.ink/2019/02/16/Cocoa/iOS/iOS%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2019-02-16T16:00:00.000Z</published>
    <updated>2019-02-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 模块化方案记录</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前东家是一家很老的（始于1997年）服务提供商，同时和大多数软件公司一样，很多服务需要额外购买，同时升级软件版本也要掏一大笔钱。这么长时间导致后台服务有多个版本，且每个客户能访问的功能五花八门，数据也是无比的杂乱。这就给客户端带来了很大的挑战，之前的解决方案是写一个包含最大公共功能的 App，再以此为基础为每一个客户定制单独的 App。但这样的 App 通常是一次性的，除非有重大的 bug，否则不会更新。终于公司下定决心重构，重构有几个目标：</p><ol><li>要将所有 App 整合为一个 App，便于维护和升级</li><li>因为是重构，要原有功能的完整和准确性，因此单元测试覆盖率要达到 70% 以上</li><li>因为客户遍及全球，因为 RTL 、弱视、盲人模式都要有</li><li>因为业务需求，需要支持功能复杂的深度链接</li><li>由于后端服务和数据复杂，为了保证客户端（Android、iOS、WindowsPhone）数据一致性，所以用 C++ 做了统一的网络请求中间层</li></ol><p>基于以上要求，能想到的最好解决方案自然就是模块化：</p><ol><li>基于路由 URL 对模块 UI 页面跳转管理</li><li>基于协议对数据的请求、缓存和分享管理</li><li>维护通用 UI 库保证满足 RTL、弱视、盲人模式的支持</li></ol><p>从结构上，整个 App 被划分为 5 层</p><p><img src="./iOS%E6%A8%A1%E5%9D%97%E5%8C%96/app-module-structure.jpg" alt="app structure"></p><h2 id="跨平台公共层"><a href="#跨平台公共层" class="headerlink" title="跨平台公共层"></a>跨平台公共层</h2><p>这一层使用 C++ 包装了多种版本和多种服务端 URL 的 Api，保证了各个客户端 Api 请求的一致性</p><h2 id="公共组件库"><a href="#公共组件库" class="headerlink" title="公共组件库"></a>公共组件库</h2><ul><li>公共数据结构 framework：C++ 层返回的请求结果都可以转换为公共的数据结构，同时也是以公共数据结构定义的结构体进行缓存；各个业务模块的数据结构都是用公共数据结构组合起来的</li><li>数据管理 framework：管理与 C++ 层的请求，将请求数据转换为客户端定义的公共结构、数据缓存等</li><li>通用 UI framework：通用 UI 库维护了 App 的基础库，同时保证基础组件满足 RTL、弱视下的大字体布局、盲人模式下的阅读、各尺寸屏幕适配等</li></ul><p><img src="./iOS%E6%A8%A1%E5%9D%97%E5%8C%96/app-common.jpg" alt="app common"></p><h2 id="模块管理层"><a href="#模块管理层" class="headerlink" title="模块管理层"></a>模块管理层</h2><ul><li>模块接口协议 ComponentProtocol：定义了模块的启动规则、生命周期、参数、数据源等，用于模块的启动</li><li>模块数据协议 DataProviderProtocol: 是一个空协议，各个子模块可以扩展协议方法。然后通过实现了该协议的类获取数据</li><li>路由管理 Router：管理模块之间的 UI 页面跳转、模块之间的参数传递、转场动画等</li></ul><p><img src="./iOS%E6%A8%A1%E5%9D%97%E5%8C%96/app-comonent.jpg" alt="app component"></p><h3 id="模块接口协议-ComponentProtocol"><a href="#模块接口协议-ComponentProtocol" class="headerlink" title="模块接口协议 ComponentProtocol"></a>模块接口协议 ComponentProtocol</h3><p>模块接口协议大致定义如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ComponentProtocol</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Component&#x27;s unqiue identifier</span></span><br><span class="line">    <span class="keyword">var</span> uid: <span class="type">String</span>! &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Component&#x27;s uri</span></span><br><span class="line">    <span class="keyword">var</span> urlComponent: <span class="type">RouterURLComponent</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Router object</span></span><br><span class="line">    <span class="keyword">var</span> router: <span class="type">Router</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Component instance&#x27;s navigate mode</span></span><br><span class="line">    <span class="keyword">var</span> navigateMode: <span class="type">RouterNavigateMode</span>! &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Component&#x27;s main entry UIViewController</span></span><br><span class="line">    <span class="keyword">var</span> viewController: <span class="type">UIViewController</span>! &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Component&#x27;s data provider</span></span><br><span class="line">    <span class="keyword">var</span> dataProvider: <span class="type">DataProvider</span>! &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// componentWIllMount() is invoked immediately before a component is mounted into component hierarchy tree</span></span><br><span class="line">    <span class="comment">/// At that moment, perform any necessarily initialize things, setup component&#x27;s state. Just remember the componentWillMount is only called once during the component lifecycle.</span></span><br><span class="line">    <span class="comment">/// Avoid introducing any UI rendering related things in this methods.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">componentWillMount</span>()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// componetWillUmount() is invoked before a component is umounted from the component hierarchy tree.</span></span><br><span class="line">    <span class="comment">/// At that moment, perform any necessary cleanup for the component at this method, such as invalidating timers, cancelling network requests, cleanup used resources.</span></span><br><span class="line">    <span class="comment">/// This method is only called once during the component&#x27;s while lifecycle.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">componentWillUnmount</span>()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// componentWillActive() is invoked before a component is presented at top of the component hierarchy tree.</span></span><br><span class="line">    <span class="comment">/// Use this as an opportunity to operate any things when the component is active for user</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">componentWillActive</span>()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// componentWillInactive is invoked before a component is no more at the top of the component hierarchy tree.</span></span><br><span class="line">    <span class="comment">/// There&#x27;re two cases</span></span><br><span class="line">    <span class="comment">///     1) The component is removed from the hierarchy tree.</span></span><br><span class="line">    <span class="comment">///     2) Another component is pushed into the tree, the component is at the second top of the tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">componentWillInactive</span>()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ComponentProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">componentWillMount</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">componentWillUnmount</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">componentWillActive</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">componentWillInactive</span>()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个模块 framework 暴露一个公共类实现模块接口，填入必要的参数例如 转场动画的模式、模块入口的 ViewController 等信息，Router 解析后会补齐进入模块的 URI、数据源 DataProvider 等信息，同时调用该类实现的生命周期方法</p><h3 id="模块数据协议-DataProviderProtocol"><a href="#模块数据协议-DataProviderProtocol" class="headerlink" title="模块数据协议 DataProviderProtocol"></a>模块数据协议 DataProviderProtocol</h3><p>模块数据协议 DataProviderProtocol 定义了当前模块获取数据的方法接口，在模块向外暴露的 Component 入口类中，规定 dataProvider 必须实现当前模块的数据协议方法，这样就能保证模块可以通过外部数据源获取数据</p><h3 id="路由管理-Router"><a href="#路由管理-Router" class="headerlink" title="路由管理 Router"></a>路由管理 Router</h3><p>路由管理模块负责维护 URL 与模块之间的对应关系，当访问到对应的模块时：</p><ol><li>初始化该模块的公共 Component 类，填充 Component 中的属性</li><li>调用对应的生命周期函数</li><li>拿到入口 ViewController，打开页面</li><li>调用 Component 的生命周期函数，这样就完成了一次模块间的跳转</li></ol><blockquote><p>Router 与 NavigationController 一一对应，因此在模块内部的 VC 间跳转也要通过 Router，否则在模块之间的跳转会打乱 VC 的栈<br>Router 会优先选择 URL 参数中的转场动画模式，如果没有设置再使用 Componet 类中定义的转场模式，这是为了 Deeplink 打开 App 时可以在用户无感知的情况下一次跳转多个页面</p></blockquote><h2 id="App-与模块的数据"><a href="#App-与模块的数据" class="headerlink" title="App 与模块的数据"></a>App 与模块的数据</h2><p>App 通过 Router 控制模块的生命周期、UI跳转，然后通过 DataProvider 的实例控制与模块之间的数据交互</p><p><img src="./iOS%E6%A8%A1%E5%9D%97%E5%8C%96/app-data-provider.jpg" alt="app dataprovider"></p><p>DataProvider 会在模块解析注册完成时注入到 Component 中，从而保证模块可以通过 Component 中的 dataProvider 拿到对应的数据</p><p>DataProvider 实例遵守 DataProvider 协议，并实现了各个模块扩展协议中的方法，它负责将公共的数据结构汇总为各个模块所需的数据结构，管理各个模块的数据请求回调等</p><blockquote><p>例如，每次打开一个模块会立即返回之前请求缓存的数据，保证 UI 可以立即渲染出来，然后 DataProvider 会保存回调，当最新的数据请求完成时，再通过回调返回新的数据</p></blockquote><h2 id="模块间通信与数据传输"><a href="#模块间通信与数据传输" class="headerlink" title="模块间通信与数据传输"></a>模块间通信与数据传输</h2><ul><li>参数：在 <code>componentWillActive</code> 生命周期函数调用之后，模块中可以拿到进入模块对应的 URL，从而可以从 URL 中解析出传入的参数，此时可以根据参数初始化入口 ViewController</li><li>数据：在 <code>componentWillMount</code> 生命周期函数调用之后，模块中可以拿到 dataProvider 对象，开启请求数据</li><li>复杂数据传输：通常模块化设计的一大问题就是复杂数据如何传输，我们使用的是缓存机制，需要传输的数据通过协议接口传递给 dateProvider 对象临时持有，下一个模块再通过指定的 key 去取出</li></ul><h2 id="模块的测试"><a href="#模块的测试" class="headerlink" title="模块的测试"></a>模块的测试</h2><p>一个模块的完整测试包括功能数据的测试与 UI 测试：</p><ul><li>由于模块采用 MVVM 的设计模式，通过 Mock 数据很容易对 VM 进行数据和功能的单元测试</li><li>而 UI 的测试也很简单，只要对当前 framework 创建一个单模块的 App，然后创建一个数据类实现模块的数据请求协议<code>MockDataProvider&lt;ComponentDataProviderProtocol&gt;</code>，在该类中 Mock 各种 UI 测试的边界数据。再在 App 中通过模块的公共 Component 类进入模块即可完整的模拟出打开模块的流程</li></ul><p><img src="./iOS%E6%A8%A1%E5%9D%97%E5%8C%96/app-test.jpg" alt="app text"></p><p>最终每个模块的项目结构如下：</p><p><img src="./iOS%E6%A8%A1%E5%9D%97%E5%8C%96/app-module.png" alt="app module"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS 模块化方案记录&lt;/p&gt;</summary>
    
    
    
    <category term="Cocoa" scheme="https://notes.honqi.ink/categories/cocoa/"/>
    
    <category term="iOS" scheme="https://notes.honqi.ink/categories/cocoa/ios/"/>
    
    <category term="模块化" scheme="https://notes.honqi.ink/categories/cocoa/ios/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS Layout Engine 与 Render Loop</title>
    <link href="https://notes.honqi.ink/2018/11/07/Cocoa/iOS/LayoutEngine/"/>
    <id>https://notes.honqi.ink/2018/11/07/Cocoa/iOS/LayoutEngine/</id>
    <published>2018-11-07T16:00:00.000Z</published>
    <updated>2018-11-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS引入自动布局之后，除了直接设置frame/bounds外，所有能影响layout的属性改动（子视图、布局约束、优先级、对齐方式等）都会经过layout engine计算转换为对应的frame值</p><p><img src="./LayoutEngine/ios-layout-engine.PNG" alt="iOS layout engine"></p><span id="more"></span><p>layout engine计算出每个视图（Rect）对应的尺寸和坐标值，再由GPU最终渲染呈现到屏幕上</p><p><img src="./LayoutEngine/ios-layout-engine-render.PNG" alt="iOS layout engine render"></p><p>整个约束改变到渲染展示的完整过程为：</p><ol><li>Runloop收集修改过的布局约束发送到layout engine</li><li>layout engine根据最新的约束更新所有受影响的约束并重新布局绘制</li><li>Runloop拿到layout engine的绘制点数据等，通过GPU等将对应的视图渲染并展示出来</li></ol><p><img src="./LayoutEngine/ios-layout-cycle.PNG" alt="iOS layout cycle"></p><h2 id="Render-Loop"><a href="#Render-Loop" class="headerlink" title="Render Loop"></a>Render Loop</h2><p>在这个过程中layout engine的工作部分被称为Render loop，可以总结为三个步骤：</p><ol><li>更新/修改约束：从子视图向上层逐级更新约束，一直到window</li><li>调整layout：从父视图向下逐层调整layout</li><li>渲染及绘制：从父视图向下逐层渲染绘制</li></ol><p><img src="./LayoutEngine/ios-layout-render-loop.PNG" alt="iOS layout render loop"></p><p>这三个步骤具体实现则是View中的一系列方法，为了保证layout的准确，每次调整都会完整的调用这些API，同时API内部也去除了很多重复性的工作：<br><strong>Update</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateConstraints;</span><br><span class="line">- (<span class="keyword">void</span>)setNeedsUpdateConstraints;</span><br><span class="line">- (<span class="keyword">void</span>)updateConstraintsIfNeeded;</span><br></pre></td></tr></table></figure><p><strong>Layout</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)layoutSubviews;</span><br><span class="line">- (<span class="keyword">void</span>)setNeedsLayout;</span><br><span class="line">- (<span class="keyword">void</span>)layoutIfNeeded;</span><br></pre></td></tr></table></figure><p><strong>Display</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect;</span><br><span class="line">- (<span class="keyword">void</span>)setNeedsDisplay;</span><br></pre></td></tr></table></figure><h2 id="Layout-engine"><a href="#Layout-engine" class="headerlink" title="Layout engine"></a>Layout engine</h2><p>当添加并激活一个约束（Constraint）的时候，layout engine会将它表示的关系<code>item1.attribute1 = multiplier × item2.attribute2 + constant</code>转换为一个多元一次方程</p><p><img src="./LayoutEngine/ios-layout-engine-function.PNG" alt="iOS layout engine function"></p><p>每个View上的多个约束的多个方程组成了一个方程组。layout engine会将这个方程组解出来，方程组的解就作为对应View的frame。</p><p><img src="./LayoutEngine/ios-layout-engine-equation.PNG" alt="iOS layout engine equation"></p><blockquote><p>如果没有解，则表示约束缺失；有多个解则是约束冲突。优先级的作用就是有多个解时选择使用优先级较高的方程组的解</p></blockquote><p>在计算出方程组的解之后，layout engine会通知对应View调用<strong>父视图</strong>的<code>setNeedsLayout()</code>方法来更新约束；从这可以知道更新约束的过程是自底向上的</p><p><img src="./LayoutEngine/ios-layout-engine-update.PNG" alt="iOS layout engine update"></p><p>在更新约束完成之后，进入layout调整阶段；每个View会从engine中复制其<strong>子视图</strong>的所有坐标数据，然后调用<code>layoutSubviews()</code>方法重新为子视图调整layout；从这点可以知道Layout调整阶段是自顶向下的</p><p><img src="./LayoutEngine/ios-layout-engine-layout.PNG" alt="iOS layout engine layout"></p><p>剩下的绘制过程则是检测是否有自定义的绘制图层、路径等；如果有就将绘制的信息打包发送到GPU渲染展示</p><h2 id="优化layout性能"><a href="#优化layout性能" class="headerlink" title="优化layout性能"></a>优化layout性能</h2><p>每次约束规则删除、添加，都会导致刷新视图并重新经历一遍引擎计算、自底向上的setNeedsLayout()的约束更新和自顶向下的Layout调整；所以我们要尽量避免频繁的增减约束</p><ul><li>应该引用需要修改的约束，并且只在必要的时候修改它</li><li>尽量不要删除所有的约束（有时一个View上的所有约束不仅仅是它自身的约束，还会有子视图及兄弟视图的约束）</li><li>尽量用<code>hide</code>的方式来替代删除视图的操作</li></ul><h3 id="systemLayoutSizeFitting"><a href="#systemLayoutSizeFitting" class="headerlink" title="systemLayoutSizeFitting()"></a>systemLayoutSizeFitting()</h3><p><code>systemLayoutSizeFitting()</code>虽然能根据Layout来自动计算其约束，但是这个方法实质是通过创建一个引擎获取对应的size，然后再将引擎销毁；所以会增加一次额外的重复，大大降低了性能</p><h3 id="intrinsicContentSize"><a href="#intrinsicContentSize" class="headerlink" title="intrinsicContentSize"></a><code>intrinsicContentSize</code></h3><p><code>intrinsicContentSize</code>属性返回一个视图固有的尺寸，设置之后layout engine不会再计算它的frame；可以提高性能。</p><blockquote><p>当固有属性改变之后，调用<code>- (void)invalidateIntrinsicContentSize;</code>方法可以让layou engine根据最新的尺寸计算位置；也可以调用<code>- (void)layoutSubviews;</code></p></blockquote><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>内容吸附（content hugging）优先级默认 250: 优先级低的会被拉伸；优先级高的被吸附<br>内容压缩阻力（compression resistance）优先级默认 750: 优先级低的会被压缩，优先级高的抗压缩阻力比较大</p><h3 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h3><p>Xcode 启动参数 <code>-UIViewLayoutFeedbackLoopDebuggingThreshold</code> &amp; <code>-NSViewLayoutFeedbackLoopDebuggingThreshold</code> 50~1000</p><p><code>systemLayoutSizeFitting(_ targetSize)</code> 会创建一个引擎计算尺寸然后再将引擎销毁，消耗性能</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS引入自动布局之后，除了直接设置frame/bounds外，所有能影响layout的属性改动（子视图、布局约束、优先级、对齐方式等）都会经过layout engine计算转换为对应的frame值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./LayoutEngine/ios-layout-engine.PNG&quot; alt=&quot;iOS layout engine&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Cocoa" scheme="https://notes.honqi.ink/categories/cocoa/"/>
    
    <category term="iOS" scheme="https://notes.honqi.ink/categories/cocoa/ios/"/>
    
    
  </entry>
  
  <entry>
    <title>cleanup，OC中的 defer</title>
    <link href="https://notes.honqi.ink/2018/10/20/Cocoa/ObjC/cleanup%EF%BC%8COC%E4%B8%AD%E7%9A%84%20defer/"/>
    <id>https://notes.honqi.ink/2018/10/20/Cocoa/ObjC/cleanup%EF%BC%8COC%E4%B8%AD%E7%9A%84%20defer/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-10-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Swift 中有个强大的语法 <code>defer</code>，可以在作用域结束的时候执行一段代码。对于一些需要在逻辑执行完成后做清理的情况来说非常简便；终于发现 OC 中可以通过 <code>__attribute__</code> 编译说明实现这一功能</p><span id="more"></span><h2 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a>cleanup</h2><p><code>cleanup</code> 声明符的作用是<strong>修饰一个变量，在当前作用域结束时可以自动执行一个指定的方法</strong>；这儿的作用域通常就是函数调用出栈之前，那么函数执行完毕以及 <code>return</code>、<code>break</code>、<code>exception</code> 等中断执行的情况都会触发</p><h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> cleanUpFunction(<span class="built_in">NSString</span> **val) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ cleanup&quot;</span>, *val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testFunc &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string __attribute__((cleanup(cleanUpFunction))) = <span class="string">@&quot;testString&quot;</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ used&quot;</span>, string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: &quot;testString used&quot; --&gt; &quot;testString cleanup&quot;</span></span><br></pre></td></tr></table></figure><h3 id="cleanup-amp-dealloc"><a href="#cleanup-amp-dealloc" class="headerlink" title="cleanup &amp; dealloc"></a>cleanup &amp; dealloc</h3><p><code>cleanup</code> 声明的方法会在类的 <code>dealloc</code> 方法之前调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DemoClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DemoClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Demo class dealloc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> demoClassCleanup(DemoClass **demo) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;demo class %@ cleanup&quot;</span>, *demo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    DemoClass *demo __attribute__((cleanup(demoClassCleanup))) = [[DemoClass alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, demo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: &lt;DemoClass: 0x600000ee0570&gt; --&gt; demo class &lt;DemoClass: 0x600000ee0570&gt; cleanup --&gt; Demo class dealloc</span></span><br></pre></td></tr></table></figure><blockquote><p>如果作用域内有多个 <code>cleanup</code> 声明的变量，<code>cleanup</code> 的调用顺序与变量的销毁顺序一致，符合调用栈<strong>后进先出</strong>的规律</p></blockquote><h2 id="cleanup-block-defer"><a href="#cleanup-block-defer" class="headerlink" title="cleanup block == defer"></a>cleanup block == defer</h2><p>Block 也是变量，所以同样可以用 cleanup 来修饰；通常一个没有返回值没有参数的 Block 的类型声明为 <code>void(^)(void)</code>，它的指针就是 <code>void(^*)(void)</code></p><p>因此可以将 Block 清理函数声明为</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _blockCleanup(<span class="keyword">void</span> (^*block)(<span class="keyword">void</span>)) &#123;</span><br><span class="line">    (*block)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候同样对 Block 变量赋值即可</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> test() &#123;</span><br><span class="line">    <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) __attribute__((cleanup(_blockCleanup), unused)) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;block executed&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将使用时对 Block 变量赋值的操作定义为宏就可以得到 <code>defer</code> 语法糖了</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> defer void(^block)(void) __attribute__((cleanup(blockCleanUp), unused)) = ^</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test() &#123;</span><br><span class="line">    defer &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;block executed&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Swift 中有个强大的语法 &lt;code&gt;defer&lt;/code&gt;，可以在作用域结束的时候执行一段代码。对于一些需要在逻辑执行完成后做清理的情况来说非常简便；终于发现 OC 中可以通过 &lt;code&gt;__attribute__&lt;/code&gt; 编译说明实现这一功能&lt;/p&gt;</summary>
    
    
    
    <category term="LLVM" scheme="https://notes.honqi.ink/categories/llvm/"/>
    
    <category term="GCC" scheme="https://notes.honqi.ink/categories/llvm/gcc/"/>
    
    <category term="__attribute__" scheme="https://notes.honqi.ink/categories/llvm/gcc/attribute/"/>
    
    <category term="ObjC" scheme="https://notes.honqi.ink/categories/llvm/gcc/attribute/objc/"/>
    
    
  </entry>
  
  <entry>
    <title>attribute 编译指令</title>
    <link href="https://notes.honqi.ink/2018/10/09/Cocoa/ObjC/attribute%20%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/"/>
    <id>https://notes.honqi.ink/2018/10/09/Cocoa/ObjC/attribute%20%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/</id>
    <published>2018-10-09T16:00:00.000Z</published>
    <updated>2018-10-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>attribute</strong> 一个用于在声明时指定一些特性的编译器指令，它可以开启很多额外的错误检查和高级优化工作。在 GCC 和 LLVM 中都有支持</p><span id="more"></span><p>它的语法格式通常为 <code>__attribute__((command))</code>，参数部分的两个括号是为了便于在宏里面使用。<br>GCC 和 LLVM 中支持的编译属性并不完全一致，如果要检查能否使用特定的属性，可以用  <code>__has_attribute</code> 这个指令</p><p>下面列举一些常用的编译指令</p><h2 id="availability"><a href="#availability" class="headerlink" title="availability"></a>availability</h2><p>可用性属性，放在声明之后表示该声明在系统版本上的支持情况</p><h2 id="constructor-destructor"><a href="#constructor-destructor" class="headerlink" title="constructor / destructor"></a>constructor / destructor</h2><p>构造器和析构器声明，有这两个声明的函数会在分别在可执行文件（或 shared library）<code>load</code> 和 <code>unload</code> 时被调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> load(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;load ...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor))</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> unload(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;unload ...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;main&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: &quot;load&quot; -&gt; &quot;main&quot; -&gt; &quot;unload&quot;</span></span><br></pre></td></tr></table></figure><h2 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a>cleanup</h2><p>用于修饰一个变量，在它的作用域结束时可以自动执行一个指定的方法。这个声明符号可以在 OC 中实现 Swift 中的 <a href="./cleanup%EF%BC%8COC%E4%B8%AD%E7%9A%84%20defer.md"><code>defer</code></a></p><h2 id="objc-runtime-name"><a href="#objc-runtime-name" class="headerlink" title="objc_runtime_name"></a>objc_runtime_name</h2><p><code>@interface</code> 或 <code>@protocol</code> 的声明符，可以将类或协议的名字在<em>编译时</em>替换</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_runtime_name(<span class="string">&quot;AnotherName&quot;</span>)))</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NormalClass</span>: <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="objc-subclassing-restricted"><a href="#objc-subclassing-restricted" class="headerlink" title="objc_subclassing_restricted"></a>objc_subclassing_restricted</h2><p>组织类被继承的属性，可以通过这个属性实现 <em>Final Class</em></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Final __attribute__((objc_subclassing_restricted))</span></span><br><span class="line"></span><br><span class="line">Final <span class="class"><span class="keyword">@interface</span> <span class="title">FinalClass</span>: <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ChildClass</span> : <span class="title">FinalClass</span>  // <span class="title">Error</span>: <span class="title">Cannot</span> <span class="title">subclass</span> <span class="title">a</span> <span class="title">class</span> <span class="title">that</span> <span class="title">was</span> <span class="title">declared</span> <span class="title">with</span> <span class="title">the</span> &#x27;<span class="title">objc_subclassing_restricted</span>&#x27; <span class="title">attribute</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="objc-requires-super"><a href="#objc-requires-super" class="headerlink" title="objc_requires_super"></a>objc_requires_super</h2><p>就是 <code>NS_REQUIRES_SUPER</code> 宏，子类重写这个属性声明的方法时必须调用 <code>super</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)mustSuperMethod <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br></pre></td></tr></table></figure><h2 id="objc-boxable"><a href="#objc-boxable" class="headerlink" title="objc_boxable"></a>objc_boxable</h2><p>ObjC 中的 <code>@(...)</code> 语法糖可以将基本数据类型装箱包装成 <code>NSNumber</code> 对象，实质上就是使用类 <code>objc_boxable</code> 声明可以装箱的属性，利用这一特性，我们可以将更多的数据类型添加到可以使用这一语法糖的行列中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __attribute__((objc_boxable)) &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> x, y, width, height;</span><br><span class="line">&#125; BoxRect;</span><br><span class="line"></span><br><span class="line">BoxRect rect = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">NSValue</span> *value = @(rect2); <span class="comment">// 将自定义的 Rect 装箱为 NSValue</span></span><br></pre></td></tr></table></figure><h2 id="overloadable"><a href="#overloadable" class="headerlink" title="overloadable"></a>overloadable</h2><p>Clang 在 C 语言中提供了 C++ 函数重载支持，通过 <code>__attribute__((overloadable))</code> 声明可以实现函数重载；只能用于 C 函数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Overload __attribute__((overloadable))</span></span><br><span class="line"></span><br><span class="line">Overload <span class="built_in">NSString</span> *overloadFunc(<span class="built_in">NSString</span> *argu) &#123;<span class="keyword">return</span> argu;&#125;</span><br><span class="line">Overload <span class="built_in">NSString</span> *overloadFunc(<span class="built_in">NSNumber</span> *argu) &#123;<span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, argu];&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://releases.llvm.org/3.8.0/tools/clang/docs/AttributeReference.html">Clang attribute</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;attribute&lt;/strong&gt; 一个用于在声明时指定一些特性的编译器指令，它可以开启很多额外的错误检查和高级优化工作。在 GCC 和 LLVM 中都有支持&lt;/p&gt;</summary>
    
    
    
    <category term="LLVM" scheme="https://notes.honqi.ink/categories/llvm/"/>
    
    <category term="GCC" scheme="https://notes.honqi.ink/categories/llvm/gcc/"/>
    
    <category term="__attribute__" scheme="https://notes.honqi.ink/categories/llvm/gcc/attribute/"/>
    
    <category term="ObjC" scheme="https://notes.honqi.ink/categories/llvm/gcc/attribute/objc/"/>
    
    
  </entry>
  
  <entry>
    <title>Category 原理</title>
    <link href="https://notes.honqi.ink/2018/09/26/Cocoa/ObjC/Category%20%E5%8E%9F%E7%90%86/"/>
    <id>https://notes.honqi.ink/2018/09/26/Cocoa/ObjC/Category%20%E5%8E%9F%E7%90%86/</id>
    <published>2018-09-26T16:00:00.000Z</published>
    <updated>2018-09-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>OC 中的 Category 是一个十分强大的特性，它可以给一个已有的类添加新的方法或是替换掉已有方法的实现。OC 是一门动态语言从这个功能就可见一斑</p><span id="more"></span><h2 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h2><p>OC 的动态特性来源于 <code>Runtime</code>；所以 <code>Category</code> 是通过 <code>Runtime</code> 的 <code>class_addMethod</code> 将方法添加到类里面或替换已有方法的吗？</p><p>带着这个疑问，我创建了一个类，然后通过 <code>class_addMethod</code> 尝试往里面添加了一个已存在的方法名，结果返回了 <code>NO</code>。添加失败！！！</p><p>看了下这个方法的文档：<code>YES if the method was added successfully, otherwise NO (for example, the class already contains a method implementation with that name).</code> 如果已有同名方法的实现是不能添加的</p><p>看来 <code>Category</code> 的实现并没有这么简单，同时在 <code>runtime</code> 中发现了 <code>Category</code> 的结构体定义</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_category &#123;</span><br><span class="line">    <span class="keyword">char</span> * _Nonnull category_name                            OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> * _Nonnull class_name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable instance_methods     OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable class_methods        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知，每个 <code>Category</code> 都是一个单独的数据结构，它与对应的类是通过保存的类名联系起来的。然后在 Runtime 中的某个时机将 Category 中的方法拷贝到对应的类中</p><h2 id="Runtime-中的实现"><a href="#Runtime-中的实现" class="headerlink" title="Runtime 中的实现"></a>Runtime 中的实现</h2><p>在 <code>Runtime</code> 源代码中可以找到具体的拷贝时间和实现</p><h3 id="Category-的注入时间"><a href="#Category-的注入时间" class="headerlink" title="Category 的注入时间"></a>Category 的注入时间</h3><p>对 <code>Category</code> 的处理逻辑在 <code>_read_images</code> 方法中，是通过 <code>map_images_nolock</code> 方法调用的。<code>map_images_nolock</code> 方法是在 <code>dyld</code> 在 <code>mapping</code> 给定的 <code>images</code> 时调用，随即会调用类的 <code>+(void)load</code> 方法</p><p>可以知道 <code>Category</code> 的注入发生在初始化 <code>Runtime</code> 的时候，并且在类的 <code>+(void)load</code> 方法调用之前完成</p><h3 id="Category-注入逻辑"><a href="#Category-注入逻辑" class="headerlink" title="Category 注入逻辑"></a>Category 注入逻辑</h3><p>（<em>objc-runtime-new.mm</em> 文件中 <code>// Discover categories.</code> 注释后的代码块）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process this category.</span></span><br><span class="line"><span class="keyword">if</span> (cls-&gt;isStubClass()) &#123;</span><br><span class="line">    <span class="comment">// Stub classes are never realized. Stub classes</span></span><br><span class="line">    <span class="comment">// don&#x27;t know their metaclass until they&#x27;re</span></span><br><span class="line">    <span class="comment">// initialized, so we have to add categories with</span></span><br><span class="line">    <span class="comment">// class methods or properties to the stub itself.</span></span><br><span class="line">    <span class="comment">// methodizeClass() will find them and add them to</span></span><br><span class="line">    <span class="comment">// the metaclass as appropriate.</span></span><br><span class="line">    <span class="keyword">if</span> (cat-&gt;instanceMethods ||</span><br><span class="line">        cat-&gt;protocols ||</span><br><span class="line">        cat-&gt;instanceProperties ||</span><br><span class="line">        cat-&gt;classMethods ||</span><br><span class="line">        cat-&gt;protocols ||</span><br><span class="line">        (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">    &#123;</span><br><span class="line">        objc::unattachedCategories.addForClass(lc, cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// First, register the category with its target class.</span></span><br><span class="line">    <span class="comment">// Then, rebuild the class&#x27;s method lists (etc) if</span></span><br><span class="line">    <span class="comment">// the class is realized.</span></span><br><span class="line">    <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols</span><br><span class="line">        ||  cat-&gt;instanceProperties)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">            attachCategories(cls, &amp;lc, <span class="number">1</span>, ATTACH_EXISTING);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            objc::unattachedCategories.addForClass(lc, cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols</span><br><span class="line">        ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">            attachCategories(cls-&gt;ISA(), &amp;lc, <span class="number">1</span>, ATTACH_EXISTING | ATTACH_METACLASS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            objc::unattachedCategories.addForClass(lc, cls-&gt;ISA());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉各种异常处理逻辑后，关于 <code>Category</code> 的实现逻辑就是上面这部分；只要是没有 <code>realized</code> 的类，都调用 <code>objc::unattachedCategories.addForClass</code> 方法将 <code>Category</code> 暂存起来；否则就直接通过 <code>attachCategories</code> 方法将 <code>Category</code> 中的 <code>property / protocol / method</code> 添加到对应的类中</p><h4 id="attachCategories"><a href="#attachCategories" class="headerlink" title="attachCategories"></a><code>attachCategories</code></h4><p><code>attachCategories</code> 方法会按照 <code>Category</code> 列表，依次将它的方法、属性、协议添加到类中</p><p><code>attachCategories</code> 添加方法、属性、协议时会<em>先将已经存在的方法移动到方法列表后面，再将新增的方法添加进方法列表中</em>；以添加方法的代码为例，剩下的属性和协议都是类似的逻辑</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachLists(List* <span class="keyword">const</span> * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        uint32_t oldCount = array()-&gt;count;</span><br><span class="line">        uint32_t newCount = oldCount + addedCount;</span><br><span class="line">        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count = newCount;</span><br><span class="line">        memmove(array()-&gt;lists + addedCount, array()-&gt;lists, </span><br><span class="line">                oldCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));  <span class="comment">// 将已存在的方法移动到后面 </span></span><br><span class="line">        memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">                addedCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!list  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">        list = addedLists[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">        List* oldList = list;</span><br><span class="line">        uint32_t oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        uint32_t newCount = oldCount + addedCount;</span><br><span class="line">        setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count = newCount;</span><br><span class="line">        <span class="keyword">if</span> (oldList) array()-&gt;lists[addedCount] = oldList;  <span class="comment">// 只有一个方法，直接放到最后面</span></span><br><span class="line">        memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">                addedCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>添加一个 Category 分为两个阶段：</p><ol><li>编译阶段：将每一个分类都生成一个单独的结构体，保存对应的信息</li><li>Runtime 阶段：将编译时生成的 Category 数据在类初始化之前合并到对应的类中</li></ol><blockquote><p>由于在扩充数组的时候 会将类中已存在的方法（属性、协议）先移动到后面，将分类的方法（属性、协议）放在前面，所以分类的数据会被优先调用</p><p>如果一个类的多个分类都实现了同一个方法，那么该方法的调用顺序就会取决于编译的顺序，后编译的分类的方法会被先调用。所以尽量避免多个分类实现同一个方法；万不得已时可以通过在 Xcode <code>Build Phases --&gt; compile Sources</code> 中改变文件的编译顺序来控制分类方法的调用</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://opensource.apple.com/tarballs/objc4/">Runtime 源代码</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;OC 中的 Category 是一个十分强大的特性，它可以给一个已有的类添加新的方法或是替换掉已有方法的实现。OC 是一门动态语言从这个功能就可见一斑&lt;/p&gt;</summary>
    
    
    
    <category term="Runtime" scheme="https://notes.honqi.ink/categories/runtime/"/>
    
    <category term="ObjC" scheme="https://notes.honqi.ink/categories/runtime/objc/"/>
    
    
  </entry>
  
  <entry>
    <title>GCD</title>
    <link href="https://notes.honqi.ink/2018/09/13/Cocoa/iOS/GCD/"/>
    <id>https://notes.honqi.ink/2018/09/13/Cocoa/iOS/GCD/</id>
    <published>2018-09-13T16:00:00.000Z</published>
    <updated>2018-09-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>GCD 是 Cocoa 中提供的系统级线程管理技术；它将多线程的管理抽象为队列 Queue。只需要将需要执行的任务添加到 Queue 中，GCD 就能调度或生成线程执行任务；同时对线程的管理是作为系统的一部分来实现的，可以实现线程的统一管理，效率也是最好的</p><span id="more"></span><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><code>Dispatch Queue</code> 是需要执行处理的等待队列；当需要执行的任务被添加到 Queue 中之后会按照先进先出的顺序被取出执行</p><blockquote><p><code>Dispatch Queue</code> 是一个链表实现的队列，其中链节点是一个 <code>dispatch_continuation_t</code> 结构体，里面包含了所执行的任务函数以及一些额外信息</p></blockquote><h3 id="Serial-Queue-和-Concurrent-Queue"><a href="#Serial-Queue-和-Concurrent-Queue" class="headerlink" title="Serial Queue 和 Concurrent Queue"></a>Serial Queue 和 Concurrent Queue</h3><p><code>Dispatch Queue</code> 分为线性执行的 <code>Serial Dispatch Queue</code> 和并发执行的 <code>Concurrent Dispatch Queue</code></p><ul><li><code>Serial Dispatch Queue</code> 需要等待 Queue 中的上一个任务执行完毕才会继续执行下一个任务；只会使用一个线程</li><li><code>Concurrent Dispatch Queue</code> 并发的同时执行多个任务；会同时使用多个线程，具体使用的<strong>线程数量由 XNU 内核根据资源情况决定并控制生成和结束</strong></li></ul><blockquote><p>由于 <code>Serial Dispatch Queue</code> 会严格控制执行的顺序，所以每一个 <code>Serial Dispatch Queue</code> 都会被单独创建一个对应的线程；因此在大量使用 <code>Serial Dispatch Queue</code> 会因为创建了过多的线程影响性能</p></blockquote><h4 id="Main-Dispatch-Queue"><a href="#Main-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue"></a>Main Dispatch Queue</h4><p><code>Main Dispatch Queue</code> 是在主线程中执行的 <code>Dispatch Queue</code>；因为主线程只有一个，所以 <code>Main Dispatch Queue</code> 是 <code>Serial Dispatch Queue</code></p><blockquote><p>所有添加到 <code>Main Dispatch Queue</code> 的任务都是在主线程的 Runloop 中执行</p></blockquote><h4 id="Global-Dispatch-Queue"><a href="#Global-Dispatch-Queue" class="headerlink" title="Global Dispatch Queue"></a>Global Dispatch Queue</h4><p><code>Global Dispatch Queue</code> 是<strong>系统的</strong>全局并发队列，所有的 App 都可以获取到它</p><p><code>Global Dispatch Queue</code> 有 4 个优先级</p><ul><li><code>High Priority</code></li><li><code>Default Priority</code></li><li><code>Low Priority</code></li><li><code>Background Priority</code></li></ul><p>XNU 内核会使用队列的优先级作为线程的执行优先级。但是由于用于处理 <code>Global Dispatch Queue</code> 的线程并不能保证实时性，所以线程优先级只是大致的判断，并不准确</p><h4 id="自定义的-Dispatch-Queue"><a href="#自定义的-Dispatch-Queue" class="headerlink" title="自定义的 Dispatch Queue"></a>自定义的 Dispatch Queue</h4><p>使用 <code>dispatch_queue_create</code> 函数生成的 Queue；无论是 <code>Serial Dispatch Queue</code> 还是 <code>Concurrent Dispatch Queue</code>，都使用与<strong>默认优先级的 <code>Global Dispatch Queue</code></strong> 相同优先级的线程处理</p><blockquote><p>GCD 中的对象需要手动进行内存管理，所以自定义的 Dispatch Queue 需要通过 <code>dispatch_retain</code> 和 <code>disptach_release</code> 管理引用计数</p></blockquote><h4 id="dispath-set-target-queue"><a href="#dispath-set-target-queue" class="headerlink" title="dispath_set_target_queue"></a>dispath_set_target_queue</h4><p><code>dispath_set_target_queue</code> 函数可以改变 <code>Dispatch Queue</code> 的优先级</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><code>Dispatch Queue</code> 的管理和调度是通过底层的 <code>Libc pthread_workqueue</code> 和内核中的 <code>XNU workqueue</code></p><p><img src="GCD/queue.jpg" alt="GCD queue"></p><h4 id="libdispatch"><a href="#libdispatch" class="headerlink" title="libdispatch"></a>libdispatch</h4><p>在 <code>libdispatch</code> 层，主要有 <code>Main Dispatch Queue</code> 和 <code>Global Dispatch Queue</code> 两种队列</p><p>其中 <code>Main Dispatch Queue</code> 通过主线程 <code>Runloop</code> 执行任务，不需要内核进行调度</p><p>而 <code>Global Dispatch Queue</code> 则按照<strong>优先级</strong>以及<strong>是否并发</strong>分为 8 种：</p><ul><li><code>Global Dispatch Queue (High Priority)</code></li><li><code>Global Dispatch Queue (Default Priority)</code></li><li><code>Global Dispatch Queue (Low Priority)</code></li><li><code>Global Dispatch Queue (Background Priority)</code></li><li><code>Global Dispatch Queue (High Overcommit Priority)</code></li><li><code>Global Dispatch Queue (Default Overcommit Priority)</code></li><li><code>Global Dispatch Queue (Low Overcommit Priority)</code></li><li><code>Global Dispatch Queue (Background Overcommit Priority)</code></li></ul><p>优先级中带有 <code>Overcommit</code> 表示用于 <code>Serial Dispatch Queue</code>，在 <code>Serial Dispatch Queue</code> 使用时，无论系统状态如何，都会强制生成新的线程处理 <code>Dispatch Queue</code></p><h4 id="Libc-pthreads"><a href="#Libc-pthreads" class="headerlink" title="Libc (pthreads)"></a>Libc (pthreads)</h4><p><code>libdispatch</code> 中的每一个种 <code>Global Dispatch Queue</code> 各自使用一个 <code>Libc</code> 中的 <code>pthread_workqueue</code></p><ol><li>在 GCD 初始化时，通过 <code>pthread_workqueue_create_np</code> 生成 <code>pthread_workqueue</code></li><li>通过 <code>pthread_workqueue</code> 的 <code>bsdthread_register</code> 和 <code>workq_open</code> 可以在 XNU 内核初始化 <code>workqueue</code> 之后获取 <code>workqueue</code> 的信息</li></ol><h4 id="XNU-内核"><a href="#XNU-内核" class="headerlink" title="XNU 内核"></a>XNU 内核</h4><p>XNU 内核中也有 4 种优先级的 <code>workqueue</code></p><ul><li>WORKQUEUE_HIGH_PRIOQUEUE</li><li>WORKQUEUE_DEFAULT_PRIOQUEUE</li><li>WORKQUEUE_LOW_PRIOQUEUE</li><li>WORKQUEUE_BG_PRIOQUEUE</li></ul><p>这四种优先级与 <code>Dispatch Queue</code> 中的优先级相同；它们之间的对应关系如下</p><p><img src="./GCD/priority-queue.png" alt="priority"></p><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>当在 <code>Global Dispatch Queue</code> 中执行任务时，完整的执行流程如下：</p><ol><li><code>libdispatch</code> 从 <code>Global Dispatch Queue</code> 队列中取出 <code>Dispatch Continuation</code> 包装的任务</li><li>将 <code>Global Dispatch Queue</code> 自身、符合其优先级的 <strong><code>workqueue</code> 信息</strong>以及 <code>Dispatch Continuation</code> 的回调函数等作为参数，调用 <code>pthread_workqueue_additem_np</code> 函数</li><li><code>pthread_workqueue_additem_np</code> 函数使用 <code>workq_kernreturn</code> 系统调用，根据传入的 <code>workqueue</code> 信息找到对应优先级的 <code>workqueue</code>，通知 <code>workqueue</code> 增加应当执行的任务</li><li>收到通知的 XNU 内核基于系统状态判断是否要生成新的线程。如果是 <code>Overcommit</code> 的 <code>Global Dispatch Queue</code>，则 <code>workqueue</code> 始终生成新的线程<ul><li><code>workqueue</code> 中生成的线程只在 <code>workqueue</code> 的线程计划表中运行，相当于线程只用于对应优先级的任务。所以与一般的线程上下文切换不同，性能会更好</li></ul></li><li><code>workqueue</code> 的线程接着调用 <code>pthread_workqueue</code> 函数，<code>pthread_workqueue</code> 函数会调用 <code>libdispatch</code> 中的回调函数，在该回调函数中执行 <code>Dispatch Continuation</code> 中的任务</li><li>任务执行完毕后，进行通知 <code>Dispatch Group</code> 任务结束、释放 <code>Dispatch Continuation</code> 等处理；执行 Queue 中的下一个任务</li></ol><h4 id="自定义-Dispatch-Queue-执行"><a href="#自定义-Dispatch-Queue-执行" class="headerlink" title="自定义 Dispatch Queue 执行"></a>自定义 Dispatch Queue 执行</h4><p>上面说明了 <code>Main Dispatch Queue</code> 和 <code>Global Dispatch Queue</code> 的执行原理。那如果是自定义的 <code>Dispatch Queue</code> 是怎么执行的呢？</p><p>自定义的 <code>Dispatch Queue</code> 都有一个执行目标 Queue，最终都是通过执行目标 Queue 执行 Queue 中的任务；理所当然的，这些执行目标 Queue 就只能是 <code>Main Dispatch Queue</code> 和 <code>Global Dispatch Queue</code> 中的其中一个</p><blockquote><p>创建的 Queue 默认使用 Default 优先级的 Global Queue 作为目标；可以使用 <code>dispatch_queue_create_with_target</code> 方法在创建时指定目标 Queue</p></blockquote><h4 id="再谈-dispath-set-target-queue"><a href="#再谈-dispath-set-target-queue" class="headerlink" title="再谈 dispath_set_target_queue"></a>再谈 dispath_set_target_queue</h4><p><code>dispath_set_target_queue</code> 函数不仅可以改变 <code>Dispatch Queue</code> 的优先级；还可以改变 Queue 的目标执行 Queue。</p><blockquote><p>如果在多个 <code>Serial Dispatch Queue</code> 中用 <code>dispath_set_target_queue</code> 函数指定执行目标为同一个 <code>Serial Dispatch Queue</code>；那么原本应该并行执行的多个 <code>Serial Dispatch Queue</code> 只能在目标 <code>Serial Dispatch Queue</code> 上串行执行</p></blockquote><h2 id="其他-GCD-功能简介"><a href="#其他-GCD-功能简介" class="headerlink" title="其他 GCD 功能简介"></a>其他 GCD 功能简介</h2><h3 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h3><p>延迟在指定 Queue 执行任务；<code>dispatch_after</code> 实质不是在指定时间之后执行任务，而是在指定时间之后将任务添加到指定的 Queue 立即执行</p><p>定时添加任务的定时器是通过 Runloop 实现的，所以时间同样不会十分精确</p><blockquote><p><code>dispatch_time</code> 用于获取相对时间；<code>dispatch_walltime</code> 用于获取绝对时间</p></blockquote><h3 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h3><p>waiting …</p><h3 id="dispatch-barrier"><a href="#dispatch-barrier" class="headerlink" title="dispatch_barrier_"></a>dispatch_barrier_</h3><h3 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h3><p><code>dispatch_apply</code> 类似于 <code>dispatch_sync</code>，会等待所有函数执行完毕</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;GCD 是 Cocoa 中提供的系统级线程管理技术；它将多线程的管理抽象为队列 Queue。只需要将需要执行的任务添加到 Queue 中，GCD 就能调度或生成线程执行任务；同时对线程的管理是作为系统的一部分来实现的，可以实现线程的统一管理，效率也是最好的&lt;/p&gt;</summary>
    
    
    
    <category term="Cocoa" scheme="https://notes.honqi.ink/categories/cocoa/"/>
    
    <category term="GCD" scheme="https://notes.honqi.ink/categories/cocoa/gcd/"/>
    
    
  </entry>
  
  <entry>
    <title>NSObject 中的消息发送应用</title>
    <link href="https://notes.honqi.ink/2018/06/13/Cocoa/ObjC/NSObject%20%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%BA%94%E7%94%A8/"/>
    <id>https://notes.honqi.ink/2018/06/13/Cocoa/ObjC/NSObject%20%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%BA%94%E7%94%A8/</id>
    <published>2018-06-13T16:00:00.000Z</published>
    <updated>2018-06-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，Objective-C 是使用消息传递机制来实现的面向对象。那么 <code>NSObject</code> 作为 Cocoa 中的基类，提供一些消息发送的方法就显得理所当然了。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>NSObject 中的消息发送更加复杂一些，它还受到线程和 Runloop 的影响</p><ul><li>可以指定发送消息到主线程或者任意一条自定义线程中执行</li><li>可以通过 Runloop 指定消息发送的时间，实现延迟执行的效果</li><li>可以指定消息执行时的 Runloop mode</li><li>可以取消 Runloop 中等待执行的方法</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当调用 <code>NSObject</code> 的 <code>performSelecter:afterDelay:</code> 时，其内部会创建一个 <code>Timer Item</code> 并添加到当前线程的 <code>RunLoop</code> 中；所以如果当前线程没有 <code>RunLoop</code>，则这个方法会失效</p><blockquote><p>由于 Cocoa 中 Runloop 是惰性加载的，所以在子线程中如果不主动获取 <code>Runloop</code>，<code>Runloop</code> 是不存在的，因此在子线程中通过 NSObject 的消息发送延迟执行以及指定 Runloop mode 的方法都不会被执行</p></blockquote><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>基于以上消息发送机制的特性，我们可以用来做一些实用的小功能</p><h3 id="将短时间内的大量调用合并为一次"><a href="#将短时间内的大量调用合并为一次" class="headerlink" title="将短时间内的大量调用合并为一次"></a>将短时间内的大量调用合并为一次</h3><p>在开发中，常常会遇到这样的问题：如果用户飞快点击一个按钮，就会不停的调用对应的方法，导致出现 bug。通常的解决方案是点击后将按钮的状态在一定时间内置为 disable 防止用户再次点击，这个方法的具体实现五花八门，有继承重写按钮类的，有通过运行时 swizzle 方法达到目的的。</p><p>但我认为最优雅的方法当属通过 NSObject 的消息发送方法实现，我们只要给 NSObject 添加一个分类，添加一个可以取消的消息发送方法即可</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)coalescePerformSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay inModes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes &#123;</span><br><span class="line">    [<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span> selector:aSelector object:anArgument];</span><br><span class="line">    [<span class="keyword">self</span> performSelector:aSelector withObject:anArgument afterDelay:delay inModes:modes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)coalescePerformSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay &#123;</span><br><span class="line">    [<span class="keyword">self</span> coalescePerformSelector:aSelector withObject:anArgument afterDelay:delay inModes:@[<span class="built_in">NSDefaultRunLoopMode</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延迟执行一个-block"><a href="#延迟执行一个-block" class="headerlink" title="延迟执行一个 block"></a>延迟执行一个 block</h3><p>可以通过消息机制延迟执行一个 block，类似于 <code>dispatch_after</code> 方法，但是用起来更加方便</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Private function</span></span><br><span class="line">- (<span class="keyword">void</span>)_privateExecuteBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block afterDelay:(<span class="built_in">NSTimeInterval</span>)delay &#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(_privateExecuteBlock:) withObject:[block <span class="keyword">copy</span>] afterDelay:delay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方式通常只能在主线程使用，如果是其他线程，建议老实用 <code>dispatch_after</code></p></blockquote><h3 id="发送多个参数"><a href="#发送多个参数" class="headerlink" title="发送多个参数"></a>发送多个参数</h3><p>系统提供的消息 Api 都只能传送一个参数，但是如果有发送多个参数，除了将参数打包之外，还可以使用 <code>NSInvocation</code> 将方法包装起来再调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector afterDelay:(<span class="built_in">NSTimeInterval</span>)delay inModes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes withFirstArgument:(<span class="keyword">id</span>)firstArgument argumentsList:(va_list)arguments &#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">self</span> methodSignatureForSelector:aSelector];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:signature];</span><br><span class="line">    [invocation setTarget:<span class="keyword">self</span>];</span><br><span class="line">    [invocation setSelector:aSelector];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> argument = firstArgument;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> idx = <span class="number">2</span>; idx &lt; signature.numberOfArguments; idx++) &#123;</span><br><span class="line">        [invocation setArgument:&amp;argument atIndex:idx];</span><br><span class="line">        argument = va_arg(arguments, <span class="built_in">NSObject</span> *);</span><br><span class="line">    &#125;</span><br><span class="line">    [invocation retainArguments];</span><br><span class="line">    [invocation performSelector:<span class="keyword">@selector</span>(invoke) withObject:<span class="literal">nil</span> afterDelay:delay inModes:modes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector afterDelay:(<span class="built_in">NSTimeInterval</span>)delay inModes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes withArguments:(<span class="keyword">id</span>)anArgument,... &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, anArgument);</span><br><span class="line">    [<span class="keyword">self</span> performSelector:aSelector afterDelay:delay inModes:modes withFirstArgument:anArgument argumentsList:ap];</span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="performSelector-内存泄漏的警告"><a href="#performSelector-内存泄漏的警告" class="headerlink" title="performSelector 内存泄漏的警告"></a>performSelector 内存泄漏的警告</h3><p>在 ARC 环境下，编译器是通过 <code>new</code>、<code>alloc</code>、<code>copy</code> 等开头的方法判断对象的持有者来进行内存管理的；因此在通过 <code>performSelector</code> 调用方法时，编译器不能准确的识别调用的方法是否属于上诉方法，所以编译时会有内存泄漏的警告。<br>解决方案也很简单，加一个编译宏关闭这个检查即可。但是这样一来又不安全，所以我们需要先自行检查</p><p><code>performSelector</code> 调用的所有方法都是拿不到返回值的，所以我们干脆就判定，如果一个方法有返回值，则它就是不安全的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)safePerformSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay inModes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSAssert</span>(strcmp([<span class="keyword">self</span> methodSignatureForSelector:aSelector].methodReturnType, <span class="keyword">@encode</span>(<span class="keyword">void</span>)) == <span class="number">0</span>, <span class="string">@&quot;Only methods that return a void value can be executed&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Warc-performSelector-leaks&quot;</span></span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:aSelector withObject:anArgument afterDelay:delay inModes:modes];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown">内存警告的讨论</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知，Objective-C 是使用消息传递机制来实现的面向对象。那么 &lt;code&gt;NSObject&lt;/code&gt; 作为 Cocoa 中的基类，提供一些消息发送的方法就显得理所当然了。&lt;/p&gt;</summary>
    
    
    
    <category term="Cocoa" scheme="https://notes.honqi.ink/categories/cocoa/"/>
    
    <category term="ObjC" scheme="https://notes.honqi.ink/categories/cocoa/objc/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 中的锁总结</title>
    <link href="https://notes.honqi.ink/2018/05/21/Cocoa/iOS/iOS%20%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>https://notes.honqi.ink/2018/05/21/Cocoa/iOS/iOS%20%E4%B8%AD%E7%9A%84%E9%94%81/</id>
    <published>2018-05-21T16:00:00.000Z</published>
    <updated>2018-05-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>线程锁</em>是为了保护共享资源的一种机制；对共享资源进行访问的代码块称为<em>临界区</em></p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁在任一时刻只能有一个持有者（只能有一个线程对象获得锁），如果资源已经被占用（自旋锁已经被别的线程持有），新的资源申请者会一直循环检查锁是否已经被释放，因此得名自旋</p><p>自旋锁是一种比较低级的保护数据结构或代码片段的原始方式，这种锁容易产生两个问题：</p><span id="more"></span><ul><li>死锁：如果试图递归的获取自旋锁必定会导致死锁</li><li>占用资源：如果没有限制，新的资源申请者会不停的循环等待，容易导致CPU资源占用过高</li></ul><blockquote><p>自旋锁只适用于每次锁的时间比较短暂的情况；因为新的资源申请者不停的循环等待，所以性能较好</p></blockquote><p>原理：理论上来说只要定义一个全局变量，用来表示锁的可用情况即可</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Bool lock = <span class="literal">false</span>; <span class="comment">// 一开始没有锁上，任何线程都可以申请锁</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(lock)&#123; <span class="comment">// 如果 lock 为 true 就一直死循环，相当于申请锁</span></span><br><span class="line">        lock = <span class="literal">true</span>; <span class="comment">// 挂上锁，这样别的线程就无法获得锁</span></span><br><span class="line">        <span class="comment">// Critical section  // 临界区</span></span><br><span class="line">        lock = <span class="literal">false</span>; <span class="comment">// 相当于释放锁，这样别的线程可以进入临界区</span></span><br><span class="line">        <span class="comment">// Reminder section // 不需要锁保护的代码 </span></span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class="line">OSSpinLockLock(&amp;lock);</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">OSSpinLockUnlock(&amp;lock);</span><br></pre></td></tr></table></figure><p>OSSpinLock 已经不再安全，主要原因发生在低优先级线程拿到锁时，高优先级线程进入忙等(busy-wait)状态，消耗大量 CPU 资源，从而导致低优先级线程拿不到 CPU 资源从而无法完成任务并释放锁，造成死锁状态。这种问题被称为优先级反转。</p><h4 id="os-unfair-lock-iOS-10-0"><a href="#os-unfair-lock-iOS-10-0" class="headerlink" title="os_unfair_lock (iOS_10.0 +)"></a>os_unfair_lock (iOS_10.0 +)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os_unfair_lock_t unfairLock;</span><br><span class="line">unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);</span><br><span class="line">os_unfair_lock_lock(unfairLock);</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">os_unfair_lock_unlock(unfairLock);</span><br></pre></td></tr></table></figure><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁和自旋锁类似，在任意时刻只能有一个持有者，新的资源申请对象只能等待。不同的点在于互斥锁的等待线程会进入睡眠状态，消耗CPU资源较低，但是由于线程需要唤醒，所以在加锁时间较短时性能不佳</p><h4 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t lock;</span><br><span class="line">pthread_mutex_init(&amp;lock, <span class="literal">nil</span>);</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line"><span class="comment">// do ...</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br><span class="line">pthread_mutex_destroy(&amp;lock);</span><br></pre></td></tr></table></figure><p>一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃</p><p>假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁</p><h4 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h4><p>NSLock 是 Objective-C 以对象的形式暴露的一种锁，只是在内部封装了一个属性为 PTHREAD_MUTEX_ERRORCHECK 的 pthread_mutex，，它损失一定性能换来错误提示</p><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized()"></a>@synchronized()</h4><p>OC 层面的锁，通过牺牲性能换来语法上的简洁与可读。</p><p>@synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(可以理解为锁池)，通过对对象计算哈希值来得到对应的互斥锁</p><h2 id="信号量-dispatch-semaphore-t"><a href="#信号量-dispatch-semaphore-t" class="headerlink" title="信号量 dispatch_semaphore_t"></a>信号量 dispatch_semaphore_t</h2><p>信号量是 GCD 模块中的一种锁机制，每次会把信号量的值减 1，判断是否大于0。如果大于零，说明不用等待，所以立刻返回；否则就需要等待</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER); </span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">dispatch_semaphore_signal(_lock);</span><br></pre></td></tr></table></figure><p>信号量的本质是使线程进入睡眠状态等待；当信号量只是0和1时于互斥锁功能相同</p><h2 id="递归锁（可重入锁）"><a href="#递归锁（可重入锁）" class="headerlink" title="递归锁（可重入锁）"></a>递归锁（可重入锁）</h2><p>递归锁属于互斥锁的一种实现，特点是可以对同一个锁多次加锁而不会导致死锁</p><h4 id="pthread-mutex-t"><a href="#pthread-mutex-t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h4><p>pthread_mutex锁也支持递归，只需要设置PTHREAD_MUTEX_RECURSIVE即可</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t lock;</span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">pthread_mutex_init(&amp;lock, &amp;attr);</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure><h4 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a>NSRecursiveLock</h4><p>递归锁是通过 pthread_mutex_lock 函数来实现，在函数内部会判断锁的类型，如果显示是递归锁，就允许递归调用，仅仅将一个计数器加一，锁的释放过程也是同理</p><p>NSRecursiveLock 与 NSLock 的区别在于内部封装的 pthread_mutex_t 对象的类型不同，前者的类型为 PTHREAD_MUTEX_RECURSIVE</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁将读写分离，例如只读锁只会在读取时加锁，同理可以单独在写的时候加锁</p><h4 id="pthread-rwlock-rdlock"><a href="#pthread-rwlock-rdlock" class="headerlink" title="pthread_rwlock_rdlock"></a>pthread_rwlock_rdlock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加读锁</span></span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"><span class="comment">//加写锁</span></span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br></pre></td></tr></table></figure><h2 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h2><p>条件锁的底层是通过条件变量(condition variable) pthread_cond_t 来实现的<br>条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> consumer () &#123; <span class="comment">// 消费者  </span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;condition_variable_signal, &amp;mutex); <span class="comment">// 等待数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// handle new data</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> producer () &#123;  </span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="comment">// 生产数据</span></span><br><span class="line">    pthread_cond_signal(&amp;condition_variable_signal); <span class="comment">// 发出信号给消费者，告诉他们有了新的数据</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h4><p>NSCondition 实质上是封装了一个互斥锁和一个条件变量， 它把前者的 lock 方法和后者的 wait/signal 统一在 NSCondition 对象中，暴露给使用者</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)signal &#123;</span><br><span class="line">  pthread_cond_signal(&amp;_condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实这个函数是通过宏来定义的，展开后就是这样</span></span><br><span class="line">- (<span class="keyword">void</span>)lock &#123;</span><br><span class="line">  <span class="keyword">int</span> err = pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h4><p>借助 NSCondition 来实现，它的本质就是一个生产者-消费者模型。“条件被满足”可以理解为生产者提供了新的内容。NSConditionLock 的内部持有一个 NSCondition 对象，以及 _condition_value 属性，在初始化时就会对这个属性进行赋值</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;线程锁&lt;/em&gt;是为了保护共享资源的一种机制；对共享资源进行访问的代码块称为&lt;em&gt;临界区&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;自旋锁&quot;&gt;&lt;a href=&quot;#自旋锁&quot; class=&quot;headerlink&quot; title=&quot;自旋锁&quot;&gt;&lt;/a&gt;自旋锁&lt;/h2&gt;&lt;p&gt;自旋锁在任一时刻只能有一个持有者（只能有一个线程对象获得锁），如果资源已经被占用（自旋锁已经被别的线程持有），新的资源申请者会一直循环检查锁是否已经被释放，因此得名自旋&lt;/p&gt;
&lt;p&gt;自旋锁是一种比较低级的保护数据结构或代码片段的原始方式，这种锁容易产生两个问题：&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://notes.honqi.ink/categories/ios/"/>
    
    <category term="锁" scheme="https://notes.honqi.ink/categories/ios/%E9%94%81/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS Layout 简介</title>
    <link href="https://notes.honqi.ink/2018/03/02/Cocoa/iOS/Layout/"/>
    <id>https://notes.honqi.ink/2018/03/02/Cocoa/iOS/Layout/</id>
    <published>2018-03-02T16:00:00.000Z</published>
    <updated>2018-03-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS中的Layout可以大概分为手动计算坐标值和使用约束自动布局两种；而自动约束布局最终也是通过引擎计算转为坐标值。</p><span id="more"></span><h2 id="手动计算坐标-Frame"><a href="#手动计算坐标-Frame" class="headerlink" title="手动计算坐标 Frame"></a>手动计算坐标 <code>Frame</code></h2><p>手动计算坐标是iOS布局中最基础的方式。这种方式最直观，UIView底层的CALayer也是使用类似的一套坐标系布局。但是缺点也很明显，对于不同尺寸的设备，通常很难通过一套代码全部适配。</p><h2 id="按比例自动调整布局-Autoresizing"><a href="#按比例自动调整布局-Autoresizing" class="headerlink" title="按比例自动调整布局 Autoresizing"></a>按比例自动调整布局 <code>Autoresizing</code></h2><p>在第一代iPad面世后，设备屏幕出现了差异，同时iPad通常要兼容横屏和竖屏两种情况，这时候通过设置frame布局就需要写不同的代码。这时候推出了<code>Autoresizing</code>，使得子视图的布局可以随着父视图自动调整。</p><blockquote><p><code>Autoresizing</code>是一种按比例布局的方案；因此只能指定与父视图的布局关系</p></blockquote><p><code>autoresizesSubviews</code>属性是控制是否自动调整子视图的开关，默认为<code>True</code></p><p>自动调整会根据 <code>autoresizingMask</code> 指定的属性枚举值来按比例调整布局；默认为 <code>UIViewAutoresizingNone</code>，表示不会自动调整</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UIViewAutoresizing</span>) &#123;</span><br><span class="line">    <span class="built_in">UIViewAutoresizingNone</span>                 = <span class="number">0</span>,         </span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>   = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleWidth</span>        = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>  = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleTopMargin</span>    = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleHeight</span>       = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>None</code> View 的 Frame 不会随 superView 变化</li><li><code>LeftMargin</code> 自动调整<em>左边距</em>大小，此时右边距不变；right 相反</li><li><code>TopMargin</code> 自动调整<em>上边距</em>大小，此时下边距不变；bottom 相反</li><li><code>Height / Width</code> 自动调整宽或高，保持4个边距不变</li></ul><blockquote><p>Mask 是位枚举，因此可以混合使用，效果叠加</p></blockquote><h2 id="自动布局-AutoLayout"><a href="#自动布局-AutoLayout" class="headerlink" title="自动布局 AutoLayout"></a>自动布局 AutoLayout</h2><p>AutoLayout 描述的是同一个图层树上的视图之间的布局关系，因此有两个重要的决定因素：</p><ul><li>参照物：另一个视图，只要是同一图层树（有共同的祖先）上的就行</li><li>约束：描述与参照物之间的位置关系</li></ul><p><strong>两个视图之间的约束关系模版为</strong> <code>item1.attribute1 = multiplier × item2.attribute2 + constant</code><br>这个模版可以使用两种方式描述：<code>VFL</code>格式和面向对象方式</p><h3 id="VFL"><a href="#VFL" class="headerlink" title="VFL"></a>VFL</h3><p>VFL(Visual Format Layout)可视化格式布局是最初用来描述AutoLayout的方式，VFL通过字符串创建 NSLayoutConstraint 对象</p><p><strong>VFL符号</strong></p><table><thead><tr><th align="center">符号</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">￨</td><td align="center">表示父视图边缘</td></tr><tr><td align="center">-</td><td align="center">表示距离， eg. <code>-100-</code> 表示两个间隔100</td></tr><tr><td align="center">V:</td><td align="center">表示竖直方向</td></tr><tr><td align="center">H:</td><td align="center">表示水平方向</td></tr><tr><td align="center">&gt;=</td><td align="center">表示视图间距、宽度和高度必须大于或等于某个值</td></tr><tr><td align="center">&lt;=</td><td align="center">表示视图间距、宽度和高度必须小宇或等于某个值</td></tr><tr><td align="center">==</td><td align="center">表示视图间距、宽度或者高度必须等于某个值</td></tr><tr><td align="center">@num</td><td align="center">优先级</td></tr><tr><td align="center">[view]</td><td align="center">[] 中放视图</td></tr><tr><td align="center">(num)</td><td align="center">() 设置视图的宽/高，eg. <code>H:￨[view(100)]</code> 表示 view 宽为 100； <code>H:￨[view(&gt;=100@751)]</code> 表示宽大于等于100，优先级为751</td></tr></tbody></table><blockquote><p>可以使用<code>NSDictionaryOfVariableBindings</code>宏创建视图名对应视图对象的字典</p></blockquote><h3 id="面向对象描述"><a href="#面向对象描述" class="headerlink" title="面向对象描述"></a>面向对象描述</h3><p>iOS中将Autolayout抽象为几个不同的类来表示：</p><h4 id="NSLayoutConstraint"><a href="#NSLayoutConstraint" class="headerlink" title="NSLayoutConstraint"></a><code>NSLayoutConstraint</code></h4><p>描述了两个<code>View</code>之间的布局关系；AutoLayou引擎会根据所描述的布局约束关系转换为视图的<code>Frame</code> 完成布局</p><h4 id="NSLayoutRelation"><a href="#NSLayoutRelation" class="headerlink" title="NSLayoutRelation"></a><code>NSLayoutRelation</code></h4><p>枚举了两个属性之间的关系，有<code>&gt;= / &gt; / = / &lt; / &lt;=</code></p><h4 id="NSLayoutAttribute"><a href="#NSLayoutAttribute" class="headerlink" title="NSLayoutAttribute"></a><code>NSLayoutAttribute</code></h4><p>枚举了可约束的布局属性</p><blockquote><p><code>Leading | Trailing</code> <em>前/后</em>属性，表示当前状态下的开始/结束方向；用于适应<code>rtl</code>和<code>ltr</code>布局，在<code>ltr</code>时等于左右，否则等于右左<br><code>LastBaseLine | FirstBaseLine</code> 基线，主要针对<code>UILabel</code>等视图，<strong>基线表示内容（文本）底部/底部的位置</strong>；对于大多数视图，基线等于<code>bottom | top</code><br><code>Margin</code> 指各个方向上的边距，等效于 <code>UIView</code> 中设置 <code>layoutMargins</code> 属性<br><code>CenterXWithinMargins</code> 指 X 轴方向上两侧的边距，同理 <code>CenterYWithinMargins</code> 指 Y 轴方向上两侧的边距<br><code>NotAnAttribute</code> 只有一个<code>Attribute</code>时用这个属性来占位，例如将高度指定为数值</p></blockquote><h4 id="NSLayoutFormatOptions"><a href="#NSLayoutFormatOptions" class="headerlink" title="NSLayoutFormatOptions"></a><code>NSLayoutFormatOptions</code></h4><p>位枚举了视图布局时的<strong>方向、对齐方式、间距（iOS 11+）</strong></p><blockquote><p>对齐方式是位枚举，可以组合使用，使用<code>AlignmentMask = 0xFFFF</code> 做掩码计算坐标属性<br>方向有<code>LeadingToTrailing | LeftToRight | RightToLeft</code>只能选择其中一个，默认为 <code>DirectionLeadingToTrailing</code>，使用<code>DirectionMask = 0x3 &lt;&lt; 16</code>做掩码<br>间距有 <code>EdgeToEdge | BaselineToBaseline</code> 只能选一个，默认为<code>BaselineToBaseline</code>，使用 <code>SpacingMask = 0x1 &lt;&lt; 19</code> 做掩码</p></blockquote><h4 id="UILayoutPriority"><a href="#UILayoutPriority" class="headerlink" title="UILayoutPriority"></a><code>UILayoutPriority</code></h4><p>布局优先级，用数值表示，最大值为 1000；系统预定义了一些优先级常量</p><ul><li><code>UILayoutPriorityRequired</code> 1000；最高优先级</li><li><code>UILayoutPriorityDefaultHigh</code> 500；保证内容不会被**压缩 (compressing)**的优先级</li><li><code>UILayoutPriorityDefaultLow</code> 250；保证内容不会被<strong>拉伸（hugs）</strong>的优先级</li><li><code>UILayoutPriorityFittingSizeLevel</code> 50；这个优先级表示计算符合内容大小的优先级</li></ul><blockquote><p>通过 <code>NSLayoutConstraint</code> 的 <code>priority</code> 属性设置优先级；无论是 LayoutConstraint、VFL 还是 Anchor，最终都是转为 <code>NSLayoutConstraint</code> 约束对象，因此都可以设置约束的优先级</p></blockquote><h6 id="抗压缩-拉伸优先级"><a href="#抗压缩-拉伸优先级" class="headerlink" title="抗压缩/拉伸优先级"></a>抗压缩/拉伸优先级</h6><p>使用优先级可以决定布局中可以拉伸、压缩的视图，也可以针对不同的布局方向设置及获取抗压缩或拉伸的优先级</p><ul><li>抗压缩的优先级 <ul><li><code>setContentHuggingPriority:(UILayoutPriority) forAxis:(UILayoutConstraintAxis)</code> </li><li><code>contentHuggingPriorityForAxis:(UILayoutConstraintAxis)</code></li></ul></li><li>抗拉伸的优先级 <ul><li><code>setContentHuggingPriority:(UILayoutPriority) forAxis:(UILayoutConstraintAxis)</code></li><li><code>contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)</code></li></ul></li></ul><blockquote><p>UILayoutConstraintAxis 是坐标轴枚举</p></blockquote><h3 id="锚点描述-LayoutAnchor"><a href="#锚点描述-LayoutAnchor" class="headerlink" title="锚点描述 LayoutAnchor"></a>锚点描述 LayoutAnchor</h3><p>为了简化创建Autolayout的方法，在iOS9之后推出了新的自动布局方案–锚点；<code>NSLayoutAnchor</code>是一个创建<code>NSLayoutConstraint</code>的工厂类；它用锚点抽象了 <code>NSLayoutAttribute</code>，使构建自动布局更加方便和简洁</p><p><strong>锚点分类</strong></p><table><thead><tr><th align="center">Type</th><th align="center">Anchor</th></tr></thead><tbody><tr><td align="center">NSLayoutDimension   （尺寸）</td><td align="center">width / height</td></tr><tr><td align="center">NSLayoutXAxisAnchor （X轴）</td><td align="center">left / right / leading / trailing / centerX</td></tr><tr><td align="center">NSLayoutYAxisAnchor （Y轴）</td><td align="center">top / bottom / firstBaseLine / lastBaseLine / centerY</td></tr></tbody></table><h2 id="其他影响Layout的属性"><a href="#其他影响Layout的属性" class="headerlink" title="其他影响Layout的属性"></a>其他影响Layout的属性</h2><h3 id="布局操纵-LayoutGuide"><a href="#布局操纵-LayoutGuide" class="headerlink" title="布局操纵 LayoutGuide"></a>布局操纵 LayoutGuide</h3><p><code>UILayoutGuide</code>也是iOS9引入，用于定义一个可以参与自动布局的<strong>矩形区域</strong>，替代占位视图（dummy view）实现元素之间的等间距效果，或封装界面模块；依赖LayoutAnchor实现</p><p><code>UILayoutGuide</code>不会在在 view 的层级树中展示，但是可以添加view到里面并展示，只是起到布局的作用；使用流程为：</p><ol><li>创建<code>UILayoutGuide</code>对象</li><li>调用<code>UIView</code>的<code>addLayoutGuide</code>方法添加到View上；意味着guide将以view的坐标作为参照；可以调用<code>UILayoutGuide</code>的<code>layoutFrame</code>属性修改自身的frame</li><li>通过anchor创建约束</li></ol><blockquote><p>将 <code>UILayoutGuide</code> 当作不能显示的View使用即可</p></blockquote><h3 id="LayoutSupport"><a href="#LayoutSupport" class="headerlink" title="LayoutSupport"></a>LayoutSupport</h3><p><code>UILayoutSupport</code>是一个布局辅助协议；仅仅被<code>UIViewController</code>的<code>topLayoutGuide</code>和<code>bottomLayoutGuide</code>属性实现，用来控制ViewController与导航栏/底部之间布局间隙</p><blockquote><p>顶部和底部都是 <code>UILayoutGuide</code>，分别有自己的顶部/底部锚点以及高度</p></blockquote><h3 id="边距布局-LayoutMargin"><a href="#边距布局-LayoutMargin" class="headerlink" title="边距布局 LayoutMargin"></a>边距布局 LayoutMargin</h3><p>边距布局LayoutMargin是iOS8开始提供的一种布局机制，当对一个View设置了起始边距之后，它的所有子视图都会默认的与父视图有一个起始边距</p><p><strong>数值型边距</strong></p><ul><li><code>UIEdgeInsets layoutMargins</code> 设置所有子视图的默认初始边距 </li><li><code>NSDirectionalEdgeInsets directionalLayoutMargins</code> 从iOS11开始提供有方向的边距 ，支持<code>rtl</code></li></ul><blockquote><p><code>layoutMargins</code>或<code>directionalLayoutMargins</code>默认会在所有子视图中都加上这个边距，<code>preservesSuperviewLayoutMargins</code>属性可以阻止这种继承，默认是 <code>NO</code>，也就是可以继承<br>当边距修改时，会触发回调<code>- layoutMarginsDidChange</code>；子视图可以重写这个方法手动修改自己的边距</p></blockquote><p><strong>占位型边距</strong></p><ul><li><code>UILayoutGuide *layoutMarginsGuide</code> </li><li><code>UILayoutGuide *readableContentGuide</code> 只读属性，定义了用户不需要操作就可以轻易看见的区域</li></ul><h3 id="安全区域-safe-area"><a href="#安全区域-safe-area" class="headerlink" title="安全区域 safe area"></a>安全区域 safe area</h3><p>从iOS11（iPhoneX问世）开始还提供了多个安全区域（不遮挡navigationbar、tabbar、toolbar等视图的区域）相关的api</p><ul><li><code>insetsLayoutMarginsFromSafeArea</code>属性，可以自动判断从安全区域开始添加边距，默认<code>YES</code></li><li><code>safeAreaInsets</code> 只读属性，返回安全区域所需的边距<blockquote><p><code>- safeAreaInsetsDidChange</code> 安全边距触发后的回调</p></blockquote></li><li><code>UILayoutGuide *safeAreaLayoutGuide</code> 安全区域占位</li></ul><h3 id="各种视图边距处理"><a href="#各种视图边距处理" class="headerlink" title="各种视图边距处理"></a>各种视图边距处理</h3><table><tr><th>视图类型</th><th>iOS 7 ～ iOS 11</th><th>iOS 11 ～</th></tr><tr><td>UIViewController</td><td> `topLayoutGuide` 和  `bottomLayoutGuide` ，iOS 11 废弃，使用 `view.safeAreaLayoutGuide` 代替</td><td>`additionalSafeAreaInsets` 管理安全边距</td></tr><tr><td>UIView</td><td></td><td> `safeAreaInsets` 和 `safeAreaLayoutGuide`</td></tr><tr><td>UIScrollView</td><td rowspan=3>使用 `UIViewController` 中的 `automaticallyAdjustsScrollViewInsets` 属性可以自动调整 `scrollview` 的边距；常出现 scrollview 部分被遮挡的 BUG，关闭这个属性解决；iOS 11 废弃</td><td>使用 `UIScrollViewContentInsetAdjustmentBehavior contentInsetAdjustmentBehavior` 属性调整边距 <ul><li>Automatic       类似 <code>ScrollableAxes</code>，但是始终会调整竖直方向上的间距</li><li>ScrollableAxes  只调整滚动的方向；<code>contentSize.width/height &gt; frame.size.width/height or alwaysBounceHorizontal/Vertical = YES</code></li><li>Never           不调整</li><li>Always          根据 <code>safeAreaInsets</code> 的值始终调整 scrollview 的安全区域</li></ul><p><code>adjustedContentInset</code> 属性可以获取实际的 contentInset, <code>contentinset</code> 属性获取的值不再准确</td></tr></p><tr><td>UITableView</td><td>引入 insetsContentViewsToSafeArea 属性，cell 的 `contentView` 会自动留出默认的安全距离；默认为 `True`</td></tr><tr><td>UICollectionView</td><td>自定义 `CollectionCell` 时通过 UIView 的相关属性设置安全边距<p><code>UICollectionViewFlowLayout</code> 提供了新的枚举属性 <code>sectionInsetReference</code> 来设置整个 collectionView 的安全距离</td></tr></p></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS中的Layout可以大概分为手动计算坐标值和使用约束自动布局两种；而自动约束布局最终也是通过引擎计算转为坐标值。&lt;/p&gt;</summary>
    
    
    
    <category term="Cocoa" scheme="https://notes.honqi.ink/categories/cocoa/"/>
    
    <category term="iOS" scheme="https://notes.honqi.ink/categories/cocoa/ios/"/>
    
    
  </entry>
  
  <entry>
    <title>Runloop</title>
    <link href="https://notes.honqi.ink/2018/01/12/Cocoa/iOS/Runloop/"/>
    <id>https://notes.honqi.ink/2018/01/12/Cocoa/iOS/Runloop/</id>
    <published>2018-01-12T16:00:00.000Z</published>
    <updated>2018-01-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Runloop 是一种事件处理模型；在很多系统和框架中都有实现。它的作用是保证线程能不停的处理新的任务，而不是处理完任务之后就退出。</p><span id="more"></span><p>通常一个线程在处理完任务之后就会立刻退出，避免占用资源。但是对于 App 来说，主线程需要等待用户的操作并且能立刻处理事件做出响应。就需要一种机制满足以下需求：</p><ul><li>处理完之后不会退出</li><li>线程能随时响应并处理事件</li><li>线程等待时不占用太多资源</li></ul><p>线程处理完事件不退出并且能随时响应的需求可以通过一个循环功能实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> run() &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// handle new task</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(True)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环不会占用太多的资源；这种实现的重点就在于：</p><ul><li>如何让线程在没有新的事件时休眠，避免浪费资源</li><li>如果管理事件，让有新的事件时通知到线程并将它唤醒</li></ul><h2 id="Cocoa-中的实现"><a href="#Cocoa-中的实现" class="headerlink" title="Cocoa 中的实现"></a>Cocoa 中的实现</h2><p>Cocoa 中的 Runloop 实现是一个对象，通过个对象管理其需要处理的事件和消息；并提供一个入口函数来开启<strong>事件循环</strong>的逻辑。</p><p>线程调用 Runloop 对象的入口函数后就会一直处于这个函数内部的 <strong>接收消息 –&gt; 处理事件 –&gt; 继续等待</strong> 的循环中，直到循环结束（收到退出的消息）为止</p><ul><li><code>CFRunloopRef</code> 是 <code>CoreFoundation</code> 中的 Runloop 实现，提供了纯 C 的 Api 接口；所有 Api 都是线程安全的</li><li><code>NSRunloop</code> 是对 <code>CFRunloopRef</code> 的面向对象封装，该对象的 Api 不是线程安全的</li></ul><h2 id="Runloop-与线程的关系"><a href="#Runloop-与线程的关系" class="headerlink" title="Runloop 与线程的关系"></a>Runloop 与线程的关系</h2><p><code>CFRunloopRef</code> 是基于 <code>pthread</code> 来管理的，Runloop 不能直接创建，只能通过 <code>CFRunLoopGetMain() &amp; CFRunLoopGetCurrent()</code> 两个函数获取</p><ul><li>线程和 Runloop 之间是一一对应的。系统维护了一个全局的 hash 表，pthread 作为键值，对应的 Runloop 是 value</li><li>线程对应的 Runloop 并不会随线程一起创建，只有第一次获取 Runloop 时才会创建</li><li>当线程被销毁时，对应的 Runloop 则会随之销毁</li></ul><blockquote><p>由于 Runloop 不主动获取不会创建，所以一些需要在 Runloop 中执行的方法在子线程中调用时可能会无效；主线程的 Runloop 会被系统早早的创建，所以不存在这个问题</p></blockquote><h2 id="Runloop-实现"><a href="#Runloop-实现" class="headerlink" title="Runloop 实现"></a>Runloop 实现</h2><p>CoreFoundation 中关于 Runloop 有 5 个类：</p><ul><li>CFRunLoopRef</li><li>CFRunLoopModeRef</li><li>CFRunLoopSourceRef</li><li>CFRunLoopTimerRef</li><li>CFRunLoopObserverRef</li></ul><p>其中 <code>CFRunLoopRef</code> 类没有对外暴露，它们之间的关系结构如下：</p><p><img src="./Runloop/CFRunLoopRef.png" alt="CFRunLoopRef"></p><ul><li>一个 Runloop 包含多个 Mode；一个 Mode 又包含多个 Source/Timer/Observer；Source/Timer/Observer 被抽象为 Mode Item</li><li>一个 Item 可以同时加入多个 Mode 中</li><li>一个 Item 被多次加入到同一个 Mode 中是无效的</li><li>如果当前的 Mode 中没有 Item，Runloop 会直接退出，<em>不进入循环</em></li></ul><h3 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h3><p>每次调用 Runloop 的主函数开启一次循环时，只能指定其中一个 Mode 作为 <code>currentMode</code>。如果需要切换 Mode，只能退出此次循环，再重新指定一个 Mode 并开启一个新的循环。这样做的目的是将不同 Mode 下的 <code>Source/Timer/Observer</code> 分隔，让其不要互相影响</p><p>CFRunLoopMode 的代码结构如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;</span><br><span class="line">    ...... <span class="comment">// Others</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="CommonModes"><a href="#CommonModes" class="headerlink" title="CommonModes"></a>CommonModes</h3><p>Runloop 中有个抽象叫 <code>CommonModes</code>：一个 Mode 可以将自己标记为 <strong>Common</strong>，它的 <code>name</code> 会被添加到 Runloop 的 <code>_commonModes</code> 属性中。之后每当 Runloop 的内容发生变化时，Runloop 都会将 <code>_commonModeItems</code> 中的 item 同步到 <code>_commonModes</code> 中记录的 Mode 中</p><blockquote><p>例如主线程中的 <code>kCFRunLoopDefaultMode &amp; UITrackingRunLoopMode</code> 两个 Mode 被标记为 Common；<code>kCFRunLoopDefaultMode</code> 是默认的 Mode，<code>UITrackingRunLoopMode</code> 是 ScrollView 滑动时的 Mode；当新的 item 被添加到 <code>_commonModeItems</code> 中时，会被同步到这两个 Mode 中，意味着它能在 App 默认状态和 ScrollView 滚动状态同时生效</p></blockquote><ul><li>Runloop 的结构</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line">    ...... <span class="comment">// Others</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p><code>CFRunLoopSourceRef</code> 是事件的封装。Source 有两个版本：</p><ul><li>Source0：只包含一个回调（函数指针），不能主动触发事件。使用时需要手动唤醒 Runloop 来处理它</li><li>Source1：包含了一个 <code>mach_port</code> 和一个回调（函数指针），用于通过内核和其他线程通信，可以主动唤醒 Runloop</li></ul><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p><code>CFRunLoopTimerRef</code> 是<strong>基于时间的触发器</strong>，包含一个时间长度和一个回调（函数指针）；当其被加入到 Runloop 时，Runloop 会注册到对应的时间点，当时间到时会唤醒 Runloop 执行回调</p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p><code>CFRunLoopObserverRef</code> 是 Runloop 观察者，每个 Observer 包含一个回调（函数指针），当 Runloop 的状态发生变化时，会调用对应观察者的回调</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),           <span class="comment">// 进入 Runloop</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),    <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>),   <span class="comment">// 即将处理 Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>),   <span class="comment">// 即将进入休眠等待</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),    <span class="comment">// 从休眠中被唤醒</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),            <span class="comment">// 退出</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U   <span class="comment">// 所有事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Runloop-接口"><a href="#Runloop-接口" class="headerlink" title="Runloop 接口"></a>Runloop 接口</h2><ul><li>Mode 接口</li></ul><p><code>CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</code><br><code>CFRunLoopRunInMode(CFStringRef modeName, ...);</code></p><blockquote><p>只能通过 <code>modeName</code> 来管理内部的 Mode；当 Add 一个 <code>modeName</code> 而内部没有对应的 Mode 时系统会自动创建对应的 Mode；Runloop 中的 Mode 只能增加不能删除</p></blockquote><ul><li>Source 接口</li></ul><p><code>CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</code><br><code>CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</code></p><ul><li>Timer 接口</li></ul><p><code>CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode) ;</code><br><code>CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mo de);</code></p><ul><li>Observer 接口</li></ul><p><code>CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFString Ref modeName);</code><br><code>CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStr ingRef modeName);</code></p><h2 id="Runloop-与-AutoreleasePool"><a href="#Runloop-与-AutoreleasePool" class="headerlink" title="Runloop 与 AutoreleasePool"></a>Runloop 与 AutoreleasePool</h2><p>App 启动后会在主线程 Runloop 中注册两个 <code>Observer</code>，回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code></p><p>在这个回调处理函数中，会区分事件的类型然后调用不同的逻辑处理 <code>AutoreleasePool</code>：</p><ul><li>第一个 Observer 只监听一个 <code>kCFRunLoopEntry</code> 事件；该事件发生时会通过 <code>_objc_autoreleasePoolPush()</code> 创建 AutoreleasePool；它的优先级最高，保证在所有回调执行之前创建 AutoreleasePool</li><li>第二个 Observer 监听了 <code>kCFRunLoopBeforeWaiting</code> 和 <code>kCFRunLoopExit</code> 两个事件；它的优先级最低，保证在所有回调之后执行逻辑<ul><li><code>kCFRunLoopBeforeWaiting</code> 休眠时会调用 <code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧的 AutoreleasePool 并立刻创建新的 AutoreleasePool</li><li><code>kCFRunLoopExit</code> 会调用 <code>_objc_autoreleasePoolPop()</code> 释放 AutoreleasePool</li></ul></li></ul><blockquote><p>之所以要在即将休眠 <code>kCFRunLoopBeforeWaiting</code> 的回调中销毁并立刻创建一个新的 AutoreleasePool；而不是在休眠唤醒 <code>kCFRunLoopAfterWaiting</code> 的回调中再创建 AutoreleasePool。是因为可能收到的信号是退出信号，这时 Runloop 不会触发休眠唤醒回调；而是直接触发 <code>kCFRunLoopExit</code> 回调</p></blockquote><h2 id="Runloop-与事件响应"><a href="#Runloop-与事件响应" class="headerlink" title="Runloop 与事件响应"></a>Runloop 与事件响应</h2><p>每个 App 进程注册了一个 <code>Source1</code>（主动唤醒 Runloop）的回调来接受系统的事件，回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code></p><p>当设备硬件的事件（触摸、旋转、锁屏等）发生后，会经历这样几个流程：</p><ol><li>由 <code>IOKit.framework</code> 框架对事件进行处理，并封装成 <code>IOHIDEvent</code> 对象并发送到 <code>SpringBoard</code></li><li><code>SpringBoard</code> 是主屏幕（同时它还处理动画和屏幕绘制）。<code>SpringBoard</code> 只会处理触摸、加速、按键等几种事件；处理后会将事件通过 <code>mach port</code> 发送到对应的 App 进程中</li><li>事件发送到 App 进程中后会触发事件回调，在回调中调用 <code>_UIApplicationHandleEventQueue()</code> 方法</li><li><code>_UIApplicationHandleEventQueue()</code> 方法将事件转为 <code>UIEvent</code> 对象并按不同的类型进行处理或分发</li></ol><blockquote><p>其中触摸、旋转等会发送给 UIWindow；通常的点击事件、<code>touchesBegin/Move/End</code> 触摸回调都是在这个回调中完成的</p></blockquote><h3 id="UIApplicationHandleEventQueue-中的手势识别"><a href="#UIApplicationHandleEventQueue-中的手势识别" class="headerlink" title="_UIApplicationHandleEventQueue 中的手势识别"></a>_UIApplicationHandleEventQueue 中的手势识别</h3><p>当进程内的回调接收到 Event 并判别它是一个手势之后，首先会取消当前的触摸回调 <code>touchesBegin/Move/End</code>，并将对应的手势标记为<em>待处理</em>，等待下一步的触摸动作以识别出具体的手势。</p><p>这个地方也用到了 Runloop 的 Observer，系统注册了一个 <code>BeforeWaiting</code>（即将休眠）的回调，在当次 Runloop 休眠之前通过 <code>_UIGestureRecognizerUpdateObserver()</code> 回调函数获取到所有被标记为<em>待处理</em>的手势，通过一系列手势识别出具体的手势类型并执行对应手势的逻辑</p><p>当手势发生了变化（创建、销毁、状态改变）时，这个回调都会进行相应的处理。例如：有些手势（长按）跨越了不止一个 Runloop，就需要在休眠前改变手势的状态等待下一个 Runloop 处理</p><h2 id="Runloop-与界面更新"><a href="#Runloop-与界面更新" class="headerlink" title="Runloop 与界面更新"></a>Runloop 与界面更新</h2><p>在 UI 更新（<code>Frame</code> 改变、<code>UIView/CALayer</code> 层级改变、手动调用 <code>setNeedsLayout/setNeedsDisplay</code>）时，对应的 <code>UIView/CALayer</code> 会被标记为<em>待处理</em>，然后打包成事务提交到一个全局容器中（SpringBoard）。</p><p>系统注册了一个 Observer 监听 <code>BeforeWaiting</code> (即将进入休眠) 和 <code>Exit</code> (即将退出Loop) 事件，该 Observer 的回调会遍历所有待处理的 <code>UIView/CAlayer</code> 以执行实际的绘制和调整，并更新 UI 界面</p><h2 id="Runloop-与动画"><a href="#Runloop-与动画" class="headerlink" title="Runloop 与动画"></a>Runloop 与动画</h2><p><code>CoreAnimation</code> 同样在 RunLoop 中注册了两个个 <code>Observer</code>，分别监听了 <code>Entry</code>和 <code>BeforeWaiting &amp; Exit</code> 事件（与 AutoreleasePool 类似，会在一个 Runloop 中自动开启一个 Transaction）</p><p><code>CALayer</code> 会捕获可动画的视图变化（例如 改变 <code>frame</code>，修改透明度，以及添加自定义动画等），之后通过 <code>CATransaction</code> 将所有变化打包提交到一个中间状态栈中。</p><p>当 RunLoop 即将进入休眠（或退出）时，<code>Observer</code> 回调会被触发将所有中间状态中的变化提交到 GPU 中进行渲染，之后 <code>CoreAnimation</code> 会通过 <code>DisplayLink</code> 等机制多次触发相关流程展示动画</p><h2 id="Runloop-与定时器"><a href="#Runloop-与定时器" class="headerlink" title="Runloop 与定时器"></a>Runloop 与定时器</h2><p>iOS 中的定时器主要有 <code>NSTimer</code> 和 <code>CADisplayLink</code> 两种</p><ul><li><code>NSTimer</code>： 其实就是 <code>CFRunLoopTimerRef</code>，注册到 Runloop 中后，RunLoop 会为其在指定的时间点注册事件，到点触发回调。但是 RunLoop 为了节省资源，并不会在非常准确的时间点执行这个回调；在资源紧张的时候回调甚至会被跳过不触发</li><li><code>CADisplayLink</code>：内部实质是通过 <code>Source</code> 设置的，是一个和屏幕刷新率一致的定时器；同样会在资源紧张的时候会被 Runloop 丢弃某次回调</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Runloop 是一种事件处理模型；在很多系统和框架中都有实现。它的作用是保证线程能不停的处理新的任务，而不是处理完任务之后就退出。&lt;/p&gt;</summary>
    
    
    
    <category term="Runloop" scheme="https://notes.honqi.ink/categories/runloop/"/>
    
    <category term="iOS" scheme="https://notes.honqi.ink/categories/runloop/ios/"/>
    
    
  </entry>
  
  <entry>
    <title>App 启动及优化</title>
    <link href="https://notes.honqi.ink/2017/12/02/Cocoa/iOS/App%E5%90%AF%E5%8A%A8%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <id>https://notes.honqi.ink/2017/12/02/Cocoa/iOS/App%E5%90%AF%E5%8A%A8%E5%8F%8A%E4%BC%98%E5%8C%96/</id>
    <published>2017-12-02T16:00:00.000Z</published>
    <updated>2017-12-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>App 启动流程及优化梳理</p><span id="more"></span><h2 id="App-启动类型"><a href="#App-启动类型" class="headerlink" title="App 启动类型"></a>App 启动类型</h2><p>App 根据是否存在于内存中以及进程是否存活可以大致分为三种启动：</p><ul><li>冷启动：App 没有被加载到内存中，也没有对应的进程存活</li><li>热启动：App 被加载到内存中，但是没有对应的进程存活</li><li>恢复响应：App 被加载到内存中，且有对应的进程存在。仅仅是从挂起状态恢复</li></ul><h2 id="App-启动流程"><a href="#App-启动流程" class="headerlink" title="App 启动流程"></a>App 启动流程</h2><p>App 启动时会调用两个标志性的函数：</p><ol><li><code>exec</code> 函数：启动时调用，该函数主要是主要是链接、加载依赖的动态库以及初始化语言的 Runtime</li><li><code>main</code> 函数：系统载入和初始化完成之后调用，开启 App 的初始化</li></ol><p>整个启动过程可以大致分为6个阶段</p><p><img src="./App%E5%90%AF%E5%8A%A8%E5%8F%8A%E4%BC%98%E5%8C%96/App-startup-phases.png" alt="App Launch phases"></p><h3 id="System-Interface"><a href="#System-Interface" class="headerlink" title="System Interface"></a>System Interface</h3><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>系统调用阶段第一步主要是 <a href="https://opensource.apple.com/source/dyld/">DYLD</a>（动态库加载器） 加载所依赖的<em>共享库</em>和<em>动态库</em>到 App 进程</p><p>官方最新的 DYLD3 相对于 DYLD 2 在载入阶段做了大量的优化</p><p><img src="App%E5%90%AF%E5%8A%A8%E5%8F%8A%E4%BC%98%E5%8C%96/app-dyld2-vs-dyld3.png" alt="dyld3 vs dyld2"></p><blockquote><p><code>mach-o</code> 是 App 自身的可执行文件（.o）集合</p></blockquote><p>在 DYLD3 中，将三个部分放到了进程之外执行并将结果缓存</p><ol><li>查找和解析 mach-o 的头文件</li><li>分析依赖的动态库</li><li>检查对应的符号表</li></ol><p><img src="App%E5%90%AF%E5%8A%A8%E5%8F%8A%E4%BC%98%E5%8C%96/dyld3-cache.png" alt="dyld3 cache"></p><blockquote><p>DYLD 3 的缓存操作是在 App 安装和更新的时候进行的</p></blockquote><p>在这个阶段优化的思路主要有：</p><ul><li>减少加载的时间：<ul><li>避免<em>链接</em>不使用的动态库（此建议针对官方提供的动态库，第三方动态库不使用则应该删除）</li><li>将一些不常用的非必须动态库延迟动态加载</li></ul></li><li>利用系统提供的缓存机制：避免在启动时动态加载动态库，因为动态加载的库不会被缓存，会拖慢 App 的启动时间</li><li>加快加载的时间：减少外部动态库的数量，可以将一些分散的功能单一的库合并成一个</li><li>加快 DYLD3 Bind&amp;Rebase 时间：Bind&amp;Rebase 会查找并调整指针，所以减少指针数量可以加快速度<ul><li>删除不用的类和方法</li><li>减少分类的数量</li><li>对于 Swift 可以尽量使用 struct （可以减少符号的数量）</li></ul></li></ul><blockquote><p>由于ASLR(address space layout randomization)技术会导致可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不相同，所以需要修复镜像中的资源指针，使之指向正确的地址。<strong>rebase 修复的是指向当前镜像内部的资源指针； 而 bind 指向的是镜像外部的资源指针</strong>。 rebase 步骤先进行，它会把镜像读入内存，并以 page 为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在 IO。随之进行的是 bind 步骤，由于要查询符号表来指向跨镜像的资源，同时需要解密在rebase阶段已被读入和加密验证的镜像，所以这一步的瓶颈在于CPU计算</p></blockquote><h4 id="libSystem-Init"><a href="#libSystem-Init" class="headerlink" title="libSystem Init"></a>libSystem Init</h4><p>系统调用阶段第二步主要是初始化系统中的动态库；这一步没有什么优化的空间</p><blockquote><p>常用的系统动态库如 libdispatch(GCD) 和 libsystem_blocks (Block)</p></blockquote><h3 id="Runtime-Init"><a href="#Runtime-Init" class="headerlink" title="Runtime Init"></a>Runtime Init</h3><p>第二个阶段是 Runtime 的初始化，这时会初始化 Objc 和 Swift 的 Runtime；之后会调用所有类的静态 <code>+ (void)load</code> 方法</p><p>这个阶段的优化主要是在调用类的静态 Load 方法时，很多库喜欢在 Load 方法中调用初始化逻辑保证第一时间做一些处理。但是这会减慢 App 的启动时间，尤其是大多数库并不会第一时间被使用的情况下更加浪费时间。因此优化的思路是：</p><ul><li>尽量避免在 <code>+[Class load]</code> 中插入逻辑；Swift 中已经废弃这个方法</li><li>可以使用 <code>+[Class initialize]</code> 方法来进来静态变量的懒初始化；这个方法会在类<strong>第一次初始化之前</strong>被调用</li><li>最好提供库的初始化方法来保证在使用该库时再进行初始化</li></ul><h3 id="UIKit-Init"><a href="#UIKit-Init" class="headerlink" title="UIKit Init"></a>UIKit Init</h3><p>第三个阶段是 UIKit 初始化阶段；在这个阶段会实例化 <code>UIApplication</code> 和 <code>UIApplicationDelegate</code>；同时开启系统的事件交互和交互</p><p>这个阶段的优化思路是尽量快的实例化 <code>UIApplication</code> 和 <code>UIApplicationDelegate</code>：</p><ul><li>减少 <code>UIApplication</code> 子类的实例化时间</li><li>减少 <code>UIApplicationDelegate</code> 实例化的时间</li></ul><h3 id="Application-Init"><a href="#Application-Init" class="headerlink" title="Application Init"></a>Application Init</h3><p>在这一阶段会触发 App 的启动回调</p><ul><li>App 生命周期回调<ul><li><code>application:willFinishLaunchingWithOptions:</code></li><li><code>application:didFinishLaunchingWithOptions</code></li></ul></li><li>UI 生命周期回调 <code>applicationDidBecomeActive:</code></li><li>iOS 13 以上使用 <code>SceneKit</code> 会触发每个 scene 的 <code>UISceneDelegate</code> 的 UI 生命周期回调<ul><li><code>scene:willConnectToSession:options:</code></li><li><code>sceneWillEnterForeground:</code></li><li><code>sceneDidBecomeActive:</code></li></ul></li></ul><blockquote><p>当 App 只是从挂起状态恢复时只会触发 UI 生命周期回调</p></blockquote><p>优化方法是尽量较少回调中的逻辑，保证回调执行的速度</p><h3 id="Initial-Frame-Render"><a href="#Initial-Frame-Render" class="headerlink" title="Initial Frame Render"></a>Initial Frame Render</h3><p>这一阶段开始进行第一帧的界面绘制，会经历创建View(<code>loadView &amp; viewDidload</code>)、Layout(<code>layoutSubviews</code>)、然后最后到绘制到屏幕上的过程</p><p>这一阶段的优化建议加快渲染的速度，可以在第一帧只展示一个尽可能简单的界面。只展示重要的数据，让用户尽量快的看到界面并且可以交互</p><h3 id="Extended"><a href="#Extended" class="headerlink" title="Extended"></a>Extended</h3><p>到这一阶段已经对 App 有足够的控制，尽量保证不要阻塞用户操作和响应即可</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;App 启动流程及优化梳理&lt;/p&gt;</summary>
    
    
    
    <category term="Cocoa" scheme="https://notes.honqi.ink/categories/cocoa/"/>
    
    <category term="iOS" scheme="https://notes.honqi.ink/categories/cocoa/ios/"/>
    
    
  </entry>
  
  <entry>
    <title>Python 元编程</title>
    <link href="https://notes.honqi.ink/2017/09/12/Python/Python%20%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    <id>https://notes.honqi.ink/2017/09/12/Python/Python%20%E5%85%83%E7%BC%96%E7%A8%8B/</id>
    <published>2017-09-12T16:00:00.000Z</published>
    <updated>2017-09-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>元编程充分发挥了动态语言的优点，可以用来简化大量重复操作</p><span id="more"></span><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h3><p>装饰器就是一个函数，它接受一个函数作为参数并返回一个新的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">demo = wrapper(demo)</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>functools.wraps</code> 装饰器来保留原函数的元信息<br><code>@wraps</code> 有一个重要特征是它能让你通过属性<code>__wrapped__</code>直接访问<strong>被包装函数</strong>；这个特性可以用来解除函数的装饰器（仅使用只有一个装饰器的情况）</p></blockquote><ul><li>如果装饰器有参数，需要再加一层包装；因为第一层包装的参数是传入的方法<code>func</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 带参数的装饰器等价于</span></span><br><span class="line">func = wrapper(args)(func)</span><br></pre></td></tr></table></figure><h3 id="类方法-实例方法作为装饰器"><a href="#类方法-实例方法作为装饰器" class="headerlink" title="类方法/实例方法作为装饰器"></a>类方法/实例方法作为装饰器</h3><p>与普通装饰器一样，仅在调用的时候存在差异</p><h3 id="类作为装饰器"><a href="#类作为装饰器" class="headerlink" title="类作为装饰器"></a>类作为装饰器</h3><p>为了将类作为一个装饰器，需要实现<code>__call__()</code> 方法，在 call 方法中完成操作</p><h4 id="为类和静态方法提供装饰器"><a href="#为类和静态方法提供装饰器" class="headerlink" title="为类和静态方法提供装饰器"></a>为类和静态方法提供装饰器</h4><p>需要在 <code>@classmethod, @staticmethod</code> 之前</p><h3 id="使用装饰器为方法增加参数"><a href="#使用装饰器为方法增加参数" class="headerlink" title="使用装饰器为方法增加参数"></a>使用装饰器为方法增加参数</h3><p>只需要在最终的 wrapper 层方法中增加参数即可</p><ul><li>只能添加强制关键字参数</li><li>函数签名中没有增加的参数，需要手动修改回来</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optional_debug</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;debug&#x27;</span> <span class="keyword">in</span> inspect.getargspec(func).args:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;debug argument already defined&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, debug=<span class="literal">False</span>, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Calling&#x27;</span>, func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    sig = inspect.signature(func)</span><br><span class="line">    parms = <span class="built_in">list</span>(sig.parameters.values())</span><br><span class="line">    parms.append(inspect.Parameter(<span class="string">&#x27;debug&#x27;</span>,</span><br><span class="line">                inspect.Parameter.KEYWORD_ONLY,</span><br><span class="line">                default=<span class="literal">False</span>))</span><br><span class="line">    wrapper.__signature__ = sig.replace(parameters=parms)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><h3 id="使用装饰器扩充类的功能"><a href="#使用装饰器扩充类的功能" class="headerlink" title="使用装饰器扩充类的功能"></a>使用装饰器扩充类的功能</h3><p>可以使用装饰器修改类的功能或扩充类的方法；是除了元类和继承之外的第三种方法</p><h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><p>使用元类创建类</p><blockquote><p>定义一个元类（继承 <code>type</code> 的类）并实现<code>__call__()</code>方法，可以在 call 方法中生成一个新的类</p></blockquote><h2 id="捕获类的属性定义顺序"><a href="#捕获类的属性定义顺序" class="headerlink" title="捕获类的属性定义顺序"></a>捕获类的属性定义顺序</h2><p>元类可以很容易的捕获类的定义信息，在 <code>__new__()</code> 方法中捕获</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, clsname, bases, clsdict</span>):</span></span><br><span class="line">        <span class="comment"># clsdict 中包含类的定义参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, clsname, bases, clsdict)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span>(<span class="params">cls, clsname, bases</span>):</span></span><br><span class="line">        <span class="keyword">return</span> OrderedDict()</span><br></pre></td></tr></table></figure><h2 id="以编程的方式定义类"><a href="#以编程的方式定义类" class="headerlink" title="以编程的方式定义类"></a>以编程的方式定义类</h2><ul><li><p>将类的定义的源代码以字符串的形式定义，接着用 <code>exec()</code> 执行</p></li><li><p>使用 <code>types.new_class()</code> 方法初始化</p><ul><li>需要传入 类名、父类元祖、关键字参数、一个<strong>填充类字典</strong>的回调函数</li><li>回调函数，它是一个用来接受类命名空间的映射对象的函数。 通常这是一个普通的字典，但是它实际上是 <code>__prepare__()</code> 方法返回的任意对象</li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Methods</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, shares, price</span>):</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.shares = shares</span><br><span class="line">    self.price = price</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.shares * self.price </span><br><span class="line">cls_dict = &#123;</span><br><span class="line">    <span class="string">&#x27;__init__&#x27;</span> : __init__,</span><br><span class="line">    <span class="string">&#x27;cost&#x27;</span> : cost,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a class</span></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line">Stock = types.new_class(<span class="string">&#x27;Stock&#x27;</span>, (), &#123;&#125;, <span class="keyword">lambda</span> ns: ns.update(cls_dict))</span><br><span class="line">Stock.__module__ = __name__</span><br></pre></td></tr></table></figure><blockquote><p>types 模块中还有其他的方法，例如仅执行准备方法， <code>types.prepare_class()</code></p></blockquote></li><li><p>直接实例化一个元类来创建类 <code>type(clsname, (), &#123;&#125;)</code></p><ul><li>这个方法相对 <code>types.new_class()</code> 它忽略了一些关键的步骤，例如<code>__prepare__()</code>的调用</li></ul></li></ul><h2 id="避免重复的属性方法"><a href="#避免重复的属性方法" class="headerlink" title="避免重复的属性方法"></a>避免重复的属性方法</h2><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p21_avoid_repetitive_property_methods.html">demo</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;元编程充分发挥了动态语言的优点，可以用来简化大量重复操作&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://notes.honqi.ink/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Objective-C 内存管理</title>
    <link href="https://notes.honqi.ink/2017/08/10/Cocoa/ObjC/OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://notes.honqi.ink/2017/08/10/Cocoa/ObjC/OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2017-08-10T16:00:00.000Z</published>
    <updated>2017-08-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>ObjC 是 C 语言的超集，所以内存需要管理分配和释放；苹果在新的 LLVM 中增加了自动内存管理机制，让<em>编译器</em>来实现内存管理</p><span id="more"></span><h2 id="引用计数-amp-MRC"><a href="#引用计数-amp-MRC" class="headerlink" title="引用计数 &amp; MRC"></a>引用计数 &amp; MRC</h2><p>引用计数是 Cocoa 中（不在OC语言中）用来管理内存的核心思想，可以说 ObjectiveC 中的内存管理就是引用计数。通过对对象的引用情况进行统计，如果对象没有任何引用（计数为0），则将该对象销毁</p><h3 id="引用计数规则"><a href="#引用计数规则" class="headerlink" title="引用计数规则"></a>引用计数规则</h3><p>引用计数的管理原则是：</p><ul><li>自己生成的对象，自己持有</li><li>非自己生成的对象，自己也可以持有</li><li>不再持有对象时要释放</li><li>非自己持有的对象不能释放</li></ul><h3 id="规则与实现"><a href="#规则与实现" class="headerlink" title="规则与实现"></a>规则与实现</h3><p>引用计数的规则都有对应的方法与之对应：</p><ul><li>生成并持有对象：<code>alloc\new\copy\mutableCopy</code> 方法与<strong>以上诉单词开头</strong>的方法<ul><li>allocate \ newer \ copying \ mutableCopyed 等方法虽然以规定的单词开头，但是不会生成并持有对象；<strong>需要方法名符合驼峰命名的规则</strong></li></ul></li><li>持有对象：<code>retain</code> 方法；不是自己生成的对象，理论上是无主的（没有任何变量持有）；需要显示的去持有它，否则会被立刻销毁</li><li>释放对象：<code>release</code> 方法：无论持有的对象是否是自己生成的，当不再需要继续持有时，必须将它释放；但是释放非自己持有的对象会导致奔溃；多次释放也会导致崩溃</li><li>销毁对象：<code>dealloc</code> 方法：当一个对象的引用次数降为0时，它会被销毁；系统会自动调用 <code>dealloc</code> 方法</li></ul><blockquote><p>以上内存管理的相关方法都由 CoreFoundation 中的基类 NSObject 中实现，因此所有的 ObjC 对象都能使用，而非 ObjC 对象则不能使用；所以说内存管理是 Cocoa 中的功能，而不是语言层面的</p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>苹果维护了一个全局的散列表（引用计数表）来管理引用计数；其中表的键值是对象内存块地址的 hash 值；这样做的好处在于</p><ul><li>引用计数表中记录了各个对象的内存块地址，可以从表中追溯到具体的对象；如果出现 bug 导致对象内存块损坏，可以通过表找到具体内存块的地址</li><li>全局引用计数表同时还方便利用工具检测内存是否泄漏</li></ul><h2 id="Autorelease-Pool"><a href="#Autorelease-Pool" class="headerlink" title="Autorelease Pool"></a>Autorelease Pool</h2><p>通过引用计数，大多数情况下只要遵守规则就能很好的管理内存，但是有些特殊情况却不能很好的处理。例如：当一个对象作为函数返回值时，它创建完被一个自动变量持有，当函数返回时，自动变量被销毁，然后释放该待返回对象，此时它的引用计数为0，对象被销毁。针对这一种情况，Cocoa 提供了另一种机制：<strong>延迟释放</strong></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>AutoreleasePool 是 Cocoa 中的延迟释放具体实现，它的原理类似于 C 中的作用域，将需要延迟释放的对象添加到 pool 中，当 pool 被销毁时（类似于变量超出作用域），pool 中的所有对象会被调用 <code>release</code> 方法。AutoreleasePool 与 Runloop 相关，每个 Runloop 循环结束时才会被销毁，因此可以保证里面的对象生命周期超出当前作用域到当前 Runloop 结束</p><h3 id="Autorelease-Pool-实现"><a href="#Autorelease-Pool-实现" class="headerlink" title="Autorelease Pool 实现"></a>Autorelease Pool 实现</h3><p>AutoreleasePool 本质上是在内部维护了一个数组，当将一个对象添加到 pool 时，就是将对象添加到内部数组。待 AutoreleasePool 对象被销毁时就遍历该数组，依次调用 <code>release</code> 方法</p><h3 id="autorelease-方法"><a href="#autorelease-方法" class="headerlink" title="autorelease 方法"></a>autorelease 方法</h3><p><code>autorelease</code> 方法的实质就是调用 <code>NSAutoreleasePool</code> 对象的 <code>+(void)addObject:</code> 方法</p><ul><li><code>+(void)addObject:</code> 类方法会获取当前的 <code>NSAutoreleasePool</code> 实例，并调用 <code>-(void)addObject:</code> 方法</li></ul><blockquote><p><code>NSAutoreleasePool</code> 的 <code>autorelease</code> 方法被重载了，对 <code>NSAutoreleasePool</code> 实例调用 <code>autorelease</code> 方法会导致崩溃</p></blockquote><h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><p>ARC 全称自动引用计数，本质上还是通过引用计数管理内存，不同之处是通过编译器完成对对象的引用计数管理</p><h3 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h3><p>ARC 中使用所有权修饰符表述引用计数的规则</p><ul><li>__strong 默认修饰符，表示强引用；持有强引用的变量在超出其作用域时被废弃，随之强引用失效，引用的对象会被释放<ul><li>对 __strong 修饰的变量赋值就满足<em>自己生成的对象自己持有；非自己生成的对象自己也能持有</em>的规则</li><li>通过销毁 __strong 修饰的变量满足<em>不再持有的对象被释放</em>的规则</li></ul></li><li>__weak 弱引用，保证引用不会持有对象；主要用于解决循环引用的问题，弱引用修饰的变量指向对象被销毁后会指向 nil</li><li>__unsafe_unretained <strong>修饰后的对象不属于编译器的内存管理对象</strong>，作用效果和 __weak 一样。但是它可能指向野指针，导致崩溃</li><li>__autoreleasing 表示会将变量注册到 Autorelease Pool</li></ul><blockquote><p>__strong | __weak | __autoreleasing 会保证将变量初始化为 <code>nil</code></p><p>__weak 会在变量引用的对象被销毁后指向 <code>nil</code>，保证程序不会崩溃；而 __unsafe_unretained 则会指向野指针</p><p>在变量间的赋值过程中，必须保证所有权修饰符一致（编译器会自动转换）</p></blockquote><h4 id="autoreleasing-使用场景"><a href="#autoreleasing-使用场景" class="headerlink" title="__autoreleasing 使用场景"></a>__autoreleasing 使用场景</h4><ul><li>返回生成但自己不持有的对象时（非 alloc\new\copy 等方法生成的），需要保证没有立刻被销毁</li><li>访问 __weak 修饰的变量时必定会注册到 Pool；因为 __weak 修饰的变量在引用过程中随时可能被销毁，只有将它添加到 Pool 中，才能保证在当前作用域中不被释放</li><li>使用（id 或对象的指针）指针时，默认会被加上 <code>__autoreleasing</code>，例如：<code>NSError * __autoreleasing * error</code>；插在中间说明是作用于对象而不是指针地址，防止指针指向的对象被销毁</li></ul><h3 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h3><ul><li><code>assign -&gt; __unsafe_unretained</code> assign 主要用于数值类型，不是OC对象，存放在栈中，不需要使用编译器管理内存</li><li><code>copy -&gt; __strong</code> 会将对象复制后再赋值</li><li><code>retain -&gt; __strong</code></li><li><code>strong -&gt; __strong</code></li><li><code>unsafe_unretained -&gt; __unsafe_unretained</code></li><li><code>weak -&gt; __weak</code></li></ul><h3 id="ARC-实现"><a href="#ARC-实现" class="headerlink" title="ARC 实现"></a>ARC 实现</h3><p>ARC 是由编译器进行内存管理，但是实质上 OC 运行时在其中也发挥了巨大的作用。</p><h4 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h4><p>编译器会在编译器针对不同的所有权修饰符插入 <code>retain</code> 和 <code>release</code> 代码；再配合运行时优化程序</p><ul><li>将成对的无用 <code>retain</code> 和 <code>release</code> 删除</li><li>直接调用底层 C API 管理引用计数</li></ul><h4 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h4><p>__weak 不需要对对象引用，理论上来说不需要处理，但是它需要实现另外两个功能：</p><ul><li>在指向的对象被销毁后将变量指向 <code>nil</code></li><li>在引用 __weak 声明的变量时需要将变量添加到 <code>autoreleasepool</code> 中</li></ul><p>针对上诉需求，系统维护了一个全局散列表，将所有 __weak 指向对象的地址作为 key，变量的地址作为 value；如果一个对象同时赋值给多个 weak 变量，则会用同一个键值注册多个 value （保存在数组中）</p><p>当对象被销毁后，操作如下</p><ol><li>从 weak 表中获取销毁对象的地址为键值的所有地址记录</li><li>将包含在地址记录中的所有变量赋值为 <code>nil</code></li><li>从 weak 表中删除该记录</li><li>从引用计数表中删除销毁对象的地址为键值的记录</li></ol><blockquote><p>因为对象被销毁后，会将 <code>nil</code> 赋值给该变量，因此使用大量 __weak 的变量会导致 CPU 资源消耗过高<br>同时如果多次<strong>使用</strong> __weak 声明的变量，每次使用都会使得该变量被注册到 <code>autorelease pool</code> 中。这种情形可以将变量暂时赋值给 __strong 修饰的变量再使用，可以保证只会被注册到 <code>autorelease pool</code> 一次。每使用一次__weak对象，运行时系统都会将其指向的原始对象先 <code>retain</code>，之后保存到自动释放池中</p></blockquote><h3 id="autoreleasing"><a href="#autoreleasing" class="headerlink" title="__autoreleasing"></a>__autoreleasing</h3><p><code>__autoreleasing</code> 等价于 MRC 环境下的 <code>autorelease</code> 方法；<code>@autoreleasepool</code> 等价于 MRC 环境下的 <code>NSAutoreleasePool</code> 类</p><h3 id="ARC-与-C"><a href="#ARC-与-C" class="headerlink" title="ARC 与 C"></a>ARC 与 C</h3><p>对象型变量不能加到 C struct\union 中，因为 ARC 是通过编译器管理内存的，编译器必须知道并且管理对象的声明周期；但是 C 结构体的生命周期是不可知的</p><blockquote><p>将对象强制转为 <code>void *</code> 指针或声明<code>__unsafe_unretained</code>不使用编译器管理内存之后可以加到 C 结构体中</p><p>OC 中的 <code>id</code> 类型与 C 中的万能指针可以通过 <code>(__bridge)</code> 互换：<code>void *p = (__bridge void *)obj &amp; id obj = (__bridge id)p;</code> 但是很容易因为野指针崩溃</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;ObjC 是 C 语言的超集，所以内存需要管理分配和释放；苹果在新的 LLVM 中增加了自动内存管理机制，让&lt;em&gt;编译器&lt;/em&gt;来实现内存管理&lt;/p&gt;</summary>
    
    
    
    <category term="Cocoa" scheme="https://notes.honqi.ink/categories/cocoa/"/>
    
    <category term="ObjC" scheme="https://notes.honqi.ink/categories/cocoa/objc/"/>
    
    
  </entry>
  
  <entry>
    <title>Block</title>
    <link href="https://notes.honqi.ink/2017/08/04/Cocoa/ObjC/Block/"/>
    <id>https://notes.honqi.ink/2017/08/04/Cocoa/ObjC/Block/</id>
    <published>2017-08-04T16:00:00.000Z</published>
    <updated>2017-08-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Blocks 是带有自动变量的<strong>匿名函数</strong>；本质上是 Objc 对象</p><span id="more"></span><h2 id="Block-的实质"><a href="#Block-的实质" class="headerlink" title="Block 的实质"></a>Block 的实质</h2><p>Block 经编译器处理后会变成一组结构体（存储数据）和一个C函数（Block实现部分）；结构体中存储了<strong>函数的实现地址、捕获的变量等信息</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block 实现结构体</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;  <span class="comment">// Block 对象指针</span></span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr; <span class="comment">// Block 的实现函数地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 名字按照一定规律动态生成的结构体</span></span><br><span class="line"><span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> Block_size; <span class="comment">// Block 所占空间大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strcut __main_block_impl_0 &#123;</span><br><span class="line">    <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">    <span class="keyword">struct</span> __main_block_desc_0 DESC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 名字按照一定规律动态生成的实现函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Block-结构体中的-isa-指针"><a href="#Block-结构体中的-isa-指针" class="headerlink" title="Block 结构体中的 isa 指针"></a>Block 结构体中的 <code>isa</code> 指针</h3><blockquote><p>Objc 中的对象和类结构体中都有一个 <code>isa</code> 指针；对象的 <code>isa</code> 指针指向对应的类；而类的 <code>isa</code> 指针则指向<strong>元类</strong></p></blockquote><p>Block 的实现部分就是一个 OC 对象。它的 <code>isa</code> 指针指向对应的类。Block 可能由三个类初始化而来：</p><ul><li>_NSConcreteStackBlock  该类的 Block 对象存储在栈上</li><li>_NSConcreteMallocBlock 该类的 Block 对象存储在堆中</li><li>_NSConcreteGlobalBlock 该类的 Block 对象存储在全局数据区（.data）</li></ul><h4 id="NSConcreteGlobalBlock"><a href="#NSConcreteGlobalBlock" class="headerlink" title="_NSConcreteGlobalBlock"></a>_NSConcreteGlobalBlock</h4><p>当 Block 不捕获自动变量时，Block 结构体实例的内容不依赖于执行时的状态，整个程序只需要一个实例，因此将 Block 实力存放在全局数据区即可</p><p>有两种情况下创建的 Block 是全局的：</p><ol><li>将 Block 作为全局变量创建时</li><li>Block 不捕获任何自动变量时</li></ol><h4 id="NSConcreteStackBlock"><a href="#NSConcreteStackBlock" class="headerlink" title="_NSConcreteStackBlock"></a>_NSConcreteStackBlock</h4><p>除 _NSConcreteGlobalBlock 之外的情况创建的 Block 都是 _NSConcreteStackBlock 类型的，存放在栈中</p><h4 id="NSConcreteMallocBlock"><a href="#NSConcreteMallocBlock" class="headerlink" title="_NSConcreteMallocBlock"></a>_NSConcreteMallocBlock</h4><p>_NSConcreteMallocBlock 通过 _NSConcreteStackBlock copy 而来。当栈上的 Block 超出作用域之后就会被拷贝到堆中，这样 Block 就可以超出作用域而继续存在</p><p>以下情况都会被拷贝：</p><ol><li>Block 作为函数返回值</li><li>Block 作为函数参数传递</li><li>Block 作为对象属性</li></ol><h4 id="Block-的-Copy"><a href="#Block-的-Copy" class="headerlink" title="Block 的 Copy"></a>Block 的 Copy</h4><ul><li>_NSConcreteStackBlock  Copy 后从栈复制到堆</li><li>_NSConcreteMallocBlock Copy 后引用计数增加</li><li>_NSConcreteGlobalBlock Copy 后什么也不做</li></ul><h2 id="Block-变量"><a href="#Block-变量" class="headerlink" title="Block 变量"></a>Block 变量</h2><p>C 语言中函数可能使用的变量有：自动（局部）变量、静态局部变量、函数参数、全局变量、静态全局变量。其中静态局部变量、全局变量、静态全局变量作用域超出函数作用域，可以在函数中多次传递；而自动变量和函数参数的作用域和函数相同， 在 Block 中<em>使用</em>时会被 Block 捕获</p><h3 id="不带-block-的变量"><a href="#不带-block-的变量" class="headerlink" title="不带 __block 的变量"></a>不带 __block 的变量</h3><p>Block 中捕获的变量是<strong>复制该变量的瞬时值</strong>，所以并且不能修改变量的值；同时在 Block <strong>执行之后</strong>改变变量的值也不会影响 Block 捕获的变量的值</p><blockquote><p>静态局部变量、全局变量、静态全局变量 同样可以在 Block 中任意读写。其中静态局部变量被 Block 捕获的是<em>变量的指针</em>，所以可以更改。而对于自动局部变量和函数参数而言，超出函数作用域后会被销毁，所以 Block 不能简单的捕获它们的指针地址来达到更改的目的。</p></blockquote><ul><li>捕获的变量会被添加到动态生成的 Block 结构体中，相当于 Block 对象自身的属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">strcut __main_block_impl_0 &#123;</span><br><span class="line">    <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">    <span class="keyword">struct</span> __main_block_desc_0 DESC;</span><br><span class="line">    <span class="keyword">int</span> val1;  <span class="comment">// 被捕获变量 val1</span></span><br><span class="line">    <span class="keyword">int</span> val2;  <span class="comment">// 被捕获变量 val2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="带有-block-的变量"><a href="#带有-block-的变量" class="headerlink" title="带有 __block 的变量"></a>带有 __block 的变量</h3><p>使用 <code>__block</code> 声明的变量可以在 Block 中更改</p><blockquote><p><code>__block</code> 是一个存储域说明符。存储域说明符用于指定变量值的存储区域或方式，C 语言中有以下存储域说明符：</p><ul><li><code>typedef</code> 与内存存储无关,由于语法原因被归入此类</li><li><code>auto</code> 默认，表明一个变量具有自动存储时期，只能用在具有代码块作用域的变量声明中，存在栈中</li><li><code>register</code> 只能用在具有代码块作用域的变量声明中，存在寄存器中</li><li><code>static</code> 静态存储，变量一旦被定义便一直存在直到程序结束</li><li><code>extern</code> 声明一个在其他地方定义了的变量</li><li><code>const</code> 将数据定为不变的，在只能定义声明，以后不可改变其值</li></ul></blockquote><p>带有 __block 声明的局部变量被捕获后会被包装为一个对象（C 结构体），从而通过结构体中的 <code>__forwarding</code> 指针指向变量</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 捕获的 __block 变量</span></span><br><span class="line"><span class="keyword">struct</span> __Block_byref_val_0 &#123;</span><br><span class="line">    <span class="keyword">void</span> *__isa;</span><br><span class="line">    __Block_byref_val_0 *__forwarding;</span><br><span class="line">    <span class="keyword">int</span> __flags;</span><br><span class="line">    <span class="keyword">int</span> __size;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样的会将变量添加到 Block 结构体中</span></span><br><span class="line">strcut __main_block_impl_0 &#123;</span><br><span class="line">    <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">    <span class="keyword">struct</span> __main_block_desc_0 DESC;</span><br><span class="line">    __Block_byref_val_0 val;  <span class="comment">// 被捕获变量 val</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，会在动态生成的描述结构体中增加 <code>copy</code> 和 <code>dispose</code> 函数来管理捕获变量的内存</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_blick_copy_0(<span class="keyword">struct</span> __main_block_impl_0 *dst, <span class="keyword">struct</span> __main_block_impl_0 *src) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_blick_dispose_0(<span class="keyword">struct</span> __main_block_impl_0 *src) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> Block_size;</span><br><span class="line">    <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0 *, <span class="keyword">struct</span> __main_block_impl_0 *);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0 *);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>__block 变量生成的结构体并不在 Block 结构体中，这样是为了多个 Block 同时捕获一个变量时节省资源</p></blockquote><h4 id="forwarding"><a href="#forwarding" class="headerlink" title="__forwarding"></a>__forwarding</h4><p>Block 使用捕获的带有 __block 声明的变量时，是通过存储的变量生成的结构体的 <code>__forwarding</code> 指针找到对应的结构体，再访问该结构体中的值</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// 得到存储的变量结构体</span></span><br><span class="line">    (val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;  <span class="comment">// 访问最终的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当 Block 从栈拷贝到堆中时，它捕获的变量也会随之一起拷贝。使用 <code>__forwarding</code> 指针来访问自身的目的在于当变量被从栈拷贝到堆中时，<code>__forwarding</code> 指针的指向会被重置为指向堆的地址，这样就可以保证栈中和堆中的 __block 变量指向的是同一个地址</p><p>初始时 __forwarding 指针指向自身。拷贝发生后堆中的  __block 变量 的 __forwarding 也指向自身</p><blockquote><p>如果两个 Block 捕获同一个 __block 变量。其中一个发生拷贝，另一个没有，则这两个 Block 对象一个引用的是栈中的 __block 变量；而另一个引用的是堆中的 __block 变量</p><p>在多个 Block 捕获同一个 __block 变量时，起初 __block 变量存储在栈上，当任意一个 Block 发生拷贝，则 __block 变量也随之拷贝到堆上。之后的 Block 再发生拷贝，只会增加 __block 变量的引用计数</p></blockquote><h3 id="Block-变量的复制和销毁"><a href="#Block-变量的复制和销毁" class="headerlink" title="Block 变量的复制和销毁"></a>Block 变量的复制和销毁</h3><p>Block 变量的复制和销毁适用 Objc 引用计数内存管理规则</p><p>Block 结构体仅在捕获变量时会生成 <code>copy</code> 和 <code>dispose</code> 函数；不捕获变量时是全局变量，不需要销毁</p><ul><li>copy 函数：在栈上的 Block 复制到堆时调用；copy 会将捕获的变量一同 copy</li><li>dispose 函数：在堆上的 Block 被销毁时调用（栈上的Block通过栈机制进行内存管理）；销毁时会将捕获的变量销毁或减去引用计数</li></ul><blockquote><p>不带 __block 的对象在 copy 和 dispose 时会被标记为 <code>BLOCK_FIELD_IS_OBJECT</code><br>__block 声明的对象在 copy 和 dispose 时会被标记为 <code>BLOCK_FIELD_IS_BYREF</code></p></blockquote><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>MRC 环境下使用 <code>__block</code> 来避免循环引用。ARC 也可以使用，但是需要在执行完时将捕获的变量手动置为 <code>nil</code>，否则还是会循环引用。同理如果没有执行 Block 也会循环引用</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Blocks 是带有自动变量的&lt;strong&gt;匿名函数&lt;/strong&gt;；本质上是 Objc 对象&lt;/p&gt;</summary>
    
    
    
    <category term="Cocoa" scheme="https://notes.honqi.ink/categories/cocoa/"/>
    
    <category term="ObjC" scheme="https://notes.honqi.ink/categories/cocoa/objc/"/>
    
    
  </entry>
  
  <entry>
    <title>Python 上下文管理</title>
    <link href="https://notes.honqi.ink/2017/06/20/Python/Python%20%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86/"/>
    <id>https://notes.honqi.ink/2017/06/20/Python/Python%20%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86/</id>
    <published>2017-06-20T16:00:00.000Z</published>
    <updated>2017-06-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>有很多操作需要处理上下文；即需要在操作前打开上下文，在操作完成后清理</p><p>例如：</p><ul><li>读取文件内容，需要先获取文件句柄，读取文件，并要处理读取时的异常；最后需要关闭文件句柄</li></ul><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    data = file.read()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    file.close()</span><br></pre></td></tr></table></figure><h2 id="with-…-as"><a href="#with-…-as" class="headerlink" title="with … as .."></a>with … as ..</h2><blockquote><p>使用 <code>with... as..</code> 可以简化上下文的管理操作</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data = file.read()</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>with…as 的原理是处理的对象必须有 <code>__enter()__ \ __exit()__</code>两个方法</p></blockquote><ul><li>with 后的代码执行后，调用 <code>__enter()__</code> 方法，将结果赋值给 as 后的变量名</li><li>当 with…as.. 作用域中的代码执行完毕后，调用 <code>__exit()__</code> 方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter</span>(<span class="params">self</span>)<span class="title">__</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;enter&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is example&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, <span class="built_in">type</span>, value, trace</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Example() <span class="keyword">as</span> exp:</span><br><span class="line">    <span class="built_in">print</span>(exp)</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><blockquote><p>with…as 可以处理异常，因为 <code>__exit()__ </code> 方法参数中的 <code>trace</code> 就是发生的异常，可以捕获并处理</p></blockquote><h2 id="contextlib"><a href="#contextlib" class="headerlink" title="contextlib"></a>contextlib</h2><h3 id="contextmanager"><a href="#contextmanager" class="headerlink" title="contextmanager"></a>contextmanager</h3><blockquote><p>contextlib.contextmanager 是对 with…as.. 的进一步简化，是一个上下文管理类</p><p>@contextmanager 是一个装饰器，它接受一个generator，用 yield 语句把 with … as var 把变量输出出去，然后 with 语句就可以正常地工作了</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextlibmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">session_scope</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Provide a transactional scope around a series of operations.&quot;&quot;&quot;</span></span><br><span class="line">    session = Session()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> session</span><br><span class="line">        session.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        session.rollback()</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        session.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_my_program</span>():</span></span><br><span class="line">    <span class="keyword">with</span> session_scope() <span class="keyword">as</span> session:</span><br><span class="line">        ThingOne().go(session)</span><br><span class="line">        ThingTwo().go(session)    </span><br></pre></td></tr></table></figure><blockquote><p>如果希望在某段代码执行前后自动执行特定代码，也可以用@contextmanager实现</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&lt;%s&gt;&quot;</span> % name)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&lt;/%s&gt;&quot;</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tag(<span class="string">&quot;h1&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="closing"><a href="#closing" class="headerlink" title="closing"></a>closing</h3><blockquote><p>contextlib.closing 是一个方法，closing 可以为对象添加上下文，变为上下文对象</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;有很多操作需要处理上下文；即需要在操作前打开上下文，在操作完成后清理&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取文件内容，需要先获取文件句柄，读取文件，并要处理读取时的异常；最后需要关闭文件句柄&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Python" scheme="https://notes.honqi.ink/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Objective-C 编码</title>
    <link href="https://notes.honqi.ink/2017/05/23/Cocoa/ObjC/ObjC%E7%BC%96%E7%A0%81/"/>
    <id>https://notes.honqi.ink/2017/05/23/Cocoa/ObjC/ObjC%E7%BC%96%E7%A0%81/</id>
    <published>2017-05-23T16:00:00.000Z</published>
    <updated>2017-05-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C中所有的类、对象、方法、协议、分类等实质都是通过C中的结构体定义，再由runtime的消息机制赋予了它们灵魂，模拟出了面向对象的特性。<br>为了良好的性能和资源消耗，在消息传递以及执行时需要将携带的信息尽可能的压缩，因此有一套单字符的编码来映射C中结构体与ObjC中的面向对象类型。</p><span id="more"></span><h2 id="类型编码表"><a href="#类型编码表" class="headerlink" title="类型编码表"></a>类型编码表</h2><p>类型编码主要应用在<strong>对象属性</strong>和<strong>方法参数、返回值</strong>上来标明它们的数据类型</p><blockquote><p><code>@encode(type-name)</code> 编译程序指令可以获取类型对应的编码字符串</p></blockquote><table><thead><tr><th>Code</th><th>Meaning</th></tr></thead><tbody><tr><td>c</td><td>A char</td></tr><tr><td>i</td><td>An int</td></tr><tr><td>s</td><td>A short</td></tr><tr><td>l</td><td>A longl is treated as a 32-bit quantity on 64-bit programs.</td></tr><tr><td>q</td><td>A long long</td></tr><tr><td>C</td><td>An unsigned char</td></tr><tr><td>I</td><td>An unsigned int</td></tr><tr><td>S</td><td>An unsigned short</td></tr><tr><td>L</td><td>An unsigned long</td></tr><tr><td>Q</td><td>An unsigned long long</td></tr><tr><td>f</td><td>A float</td></tr><tr><td>d</td><td>A double &amp; long double</td></tr><tr><td>B</td><td>A C++ bool or a C99 _Bool</td></tr><tr><td>v</td><td>A void</td></tr><tr><td>*</td><td>A character string (char *)</td></tr><tr><td>@</td><td>An object (whether statically typed or typed id)</td></tr><tr><td>#</td><td>A class object (Class)</td></tr><tr><td>:</td><td>A method selector (SEL)</td></tr><tr><td>[array type]</td><td>An array</td></tr><tr><td>{name=type…}</td><td>A structure</td></tr><tr><td>(name=type…)</td><td>A union</td></tr><tr><td>bnum</td><td>A bit field of num bits</td></tr><tr><td>^type</td><td>A pointer to type</td></tr><tr><td>?</td><td>An unknown type (among other things, this code is used for function pointers)</td></tr></tbody></table><h2 id="方法的编码格式"><a href="#方法的编码格式" class="headerlink" title="方法的编码格式"></a>方法的编码格式</h2><p>方法的格式编码是一个字符串，按照顺序分段表示对应的信息：</p><ul><li>第一段以开始的所有<code>字符</code>为标志，表示返回值类型</li><li>第二段以<code>数字</code>为标志，表示方法参数占用空间总长度</li><li>第三段以<code>@</code>为开始标志，跟着的<code>数字</code>表示方法所属的对象的地址偏移；为0表示<code>self</code></li><li>第四段以<code>:</code>为标志，后面的<code>数字</code>表示方法的SEL对象的地址偏移</li><li>最后以<code>字符+数字</code>为分组标志分组，每一组表示方法的一个参数类型及地址偏移</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, method_getTypeEncoding(class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewDidAppear:))));</span><br><span class="line"></span><br><span class="line"><span class="comment">//- (void)viewWillAppear:(BOOL)animated  -&gt; v20@0:8B16</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><code>v</code> 表示返回值为 void</li><li><code>20</code> 表示方法参数的占用空间总长度</li><li><code>@0</code> 表示方法的所属对象，其中 0 表示对象地址偏移量为 0（self）</li><li><code>:8</code> 表示方法的 SEL 对象，其中 8 表示SEL地址偏移量为 8</li><li><code>B16</code> 表示参数为 Bool 类型，地址在偏移量16处 （16 是加上对象和SEL的地址之后的偏移量）；一共长 20， Bool 在16处，说明占用了4个字节</li></ul></blockquote><h2 id="属性的编码格式"><a href="#属性的编码格式" class="headerlink" title="属性的编码格式"></a>属性的编码格式</h2><p>属性的编码格式同样是一个字符串，它以逗号 <code>,</code> 分隔每一段的信息：</p><ul><li>第一段是以 <code>T</code> 开头的字符串，表示属性值<strong>类型</strong>；T后面跟着<strong>类型编码</strong>，表示该属性的数据类型</li><li>最后一段是以 <code>V_</code> 开头的字符串，表示<strong>属性名</strong></li><li>其余信息在字符串中间表示属性的 <code>@property</code> 关键字信息；可能有多段，也可能没有；包含原子性、内存管理语义等</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> num;</span><br><span class="line"><span class="comment">// NSLog(@&quot;%s&quot;, property_getAttributes(class_getProperty([self class], &quot;num&quot;))); --&gt; Tq,N,V_num </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="comment">// NSLog(@&quot;%s&quot;, property_getAttributes(class_getProperty([self class], &quot;name&quot;))); --&gt; T@&quot;NSString&quot;,&amp;,N,V_name </span></span><br></pre></td></tr></table></figure><h3 id="property-关键字编码表"><a href="#property-关键字编码表" class="headerlink" title="property 关键字编码表"></a>property 关键字编码表</h3><table><thead><tr><th>Code</th><th>Meaning</th></tr></thead><tbody><tr><td>R</td><td>The property is read-only (readonly).</td></tr><tr><td>C</td><td>The property is a copy of the value last assigned (copy).</td></tr><tr><td>&amp;</td><td>The property is a reference to the value last assigned (retain).</td></tr><tr><td>N</td><td>The property is non-atomic (nonatomic).</td></tr><tr><td>G<name></td><td>The property defines a custom getter selector name. The name follows the G (for example, GcustomGetter,).</td></tr><tr><td>S<name></td><td>The property defines a custom setter selector name. The name follows the S (for example, ScustomSetter:,).</td></tr><tr><td>D</td><td>The property is dynamic (@dynamic).</td></tr><tr><td>W</td><td>The property is a weak reference (__weak).</td></tr><tr><td>P</td><td>The property is eligible for garbage collection.</td></tr><tr><td>t<encoding></td><td>Specifies the type using old-style encoding.</td></tr></tbody></table><h3 id="属性和实例变量的差别"><a href="#属性和实例变量的差别" class="headerlink" title="属性和实例变量的差别"></a>属性和实例变量的差别</h3><ul><li>属性用 <code>@property</code> 关键字声明，而实例变量声明在 <code>&#123; &#125;</code> 中</li><li>实例变量默认只有类内部可以访问</li><li>属性就是实例变量加上 <code>setter</code>、 <code>getter</code> 方法</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Objective-C中所有的类、对象、方法、协议、分类等实质都是通过C中的结构体定义，再由runtime的消息机制赋予了它们灵魂，模拟出了面向对象的特性。&lt;br&gt;为了良好的性能和资源消耗，在消息传递以及执行时需要将携带的信息尽可能的压缩，因此有一套单字符的编码来映射C中结构体与ObjC中的面向对象类型。&lt;/p&gt;</summary>
    
    
    
    <category term="Cocoa" scheme="https://notes.honqi.ink/categories/cocoa/"/>
    
    <category term="ObjC" scheme="https://notes.honqi.ink/categories/cocoa/objc/"/>
    
    
  </entry>
  
  <entry>
    <title>Objective-C简介</title>
    <link href="https://notes.honqi.ink/2017/05/05/Cocoa/ObjC/ObjC%E7%AE%80%E4%BB%8B/"/>
    <id>https://notes.honqi.ink/2017/05/05/Cocoa/ObjC/ObjC%E7%AE%80%E4%BB%8B/</id>
    <published>2017-05-05T16:00:00.000Z</published>
    <updated>2017-05-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C是C语言的严格超集－－任何C语言程序不经修改就可以直接通过Objective-C编译器，在Objective-C中使用C语言代码也是完全合法的。Objective-C的原意就是在C语言主体上加入面向对象的特性</p><span id="more"></span><p>ObjC是通过C语言模拟了Smalltalk的消息传递机制来实现面向对象的特性的；因此其他所有非面向对象的语法都与C语言中一致。</p><h2 id="消息机制（Runtime）"><a href="#消息机制（Runtime）" class="headerlink" title="消息机制（Runtime）"></a><a href="https://developer.apple.com/documentation/objectivec/objective_c_runtime#//apple_ref/doc/uid/TP40001418">消息机制（Runtime）</a></h2><p>ObjC的最大特点就是承自SmallTalk的消息传递机制。与其他主流面向对象语言风格不同，在ObjC中调用对象的方法实质上是<strong>向对象绑定的函数传递消息</strong>。<br>主流面向对象语言中类别与方法的关系清晰严格，一个方法必定属于一个类，在编译时就已经绑定，不可能调用一个类别中不存在的方法。在ObjC中，类别与函数的关系比较松散，它们之间仅仅通过一个类别中存储的函数表来构建联系，当调用某个方法时，类别的实例对象将消息发送到方法；所有的方法都被视为对消息的回应，而消息的处理则会在执行时才会动态的决定（Runtime）。</p><p>Runtime是一个C语言和汇编混合实现的库，它是ObjC语言的核心和动力。Runtime通过C语言的结构体定义了ObjC中类、对象、方法、函数、协议等数据结构，同时实现了它们之间的消息传递机制</p><h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>通过Runtime发送一个消息后，会找到接收该消息的对象实例并将消息传递给它。<br>一个对象在接收到消息之后，有三种可能的处理方式：一、回应该消息并执行方法；二、若无法回应，则可以将消息转发给其他对象；三、若前两个途径均不能处理该消息，则使用处理意外的方法处理该消息–默认是抛出错误；因此如果对象中接收到了一个无法处理的消息，也<strong>只会在执行期抛出异常</strong>，不会出现错误或崩溃；这一特性使得ObjC天生具有鸭子类型的动态绑定能力，也使得ObjC成为一门动态语言。</p><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p>ObjC中所有消息都是通过Runtime中的<code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code>方法发送的；该方法的第一个参数<code>receiver</code>是接收消息的对象，第二个参数<code>selector</code>是调用的函数签名，剩下的则是传递的函数参数</p><blockquote><p>这个消息函数只有编译器能调用，不能手动调用</p></blockquote><p>当调用一个ObjC方法时，并没有显示的指定<code>receiver</code> 和 <code>selector</code>，这两个参数是Runtime自动添加的，<code>receiver</code>是该方法所属的对象，而<code>selector</code>则是ObjC方法对应的C函数的签名</p><blockquote><p>每一个ObjC方法实质上都是一个至少带有<code>receiver</code>（接受对象）和<code>_cmd</code>（执行的selector）的C语言函数，ObjC方法和C函数的对应关系存储在类的一个函数表中</p></blockquote><p>在被调用的方法实现中，可以获取这两个参数信息</p><ul><li><code>getTheReceiver()</code> 方法可以获取接收对象，一般是 <code>self</code></li><li><code>getTheMethod()</code> 方法可以获取 <code>selector</code></li></ul><h3 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h3><p>消息通过<code>objc_msgSend</code>函数发出之后，首先经历的是查找的过程。</p><ol><li>根据 <code>receiver</code> 对象的<code>isa</code>指针找到该对象实现的<em>类对象</em><blockquote><p>对象结构体中只有一个指向类结构体的isa指针</p></blockquote></li><li>查询类对象中方法函数列表 <code>methodlists</code>，通过函数签名结构体<code>SEL</code>查找对应的实现结构体<code>Method</code>；如果在当前类中找不到会沿着继承链向上查找<blockquote><p>在消息的接收过程中，类结构体中的几个元素至关重要</p><ul><li>isa 指针：用于确定消息接收者实例对象</li><li>super_class 指针：用于找不到对应的函数签名时继续沿父类查找，直到根对象</li><li>methodList 类调度表(dispatch table)：保存了自身持有的所有方法的散列表（方法名和地址），可以通过 Selector 中的方法名找到对应的方法地址</li><li>cache 方法列表：为了提高效率，Runtime 会缓存调用过的 Selector 和方法地址，在调度表methodList中查找之前会先去cache中找</li></ul></blockquote></li><li>得到函数结构体<code>Method</code>后，可以确定函数实现指针<code>IMP</code>和对应的参数，调用该函数</li></ol><h4 id="提高调用效率"><a href="#提高调用效率" class="headerlink" title="提高调用效率"></a>提高调用效率</h4><p>动态特性使得每次调用方法都会经历一系列的查找，虽有会有缓存，但是还是要经历消息的发送接收查找过程，只是减少了查找的次数。因此如果需要连续的调用一个方法多次，<strong>可以通过获取方法地址直接调用的方式来提高速度</strong></p><p><code>methodForSelector:</code> 方法可以获取对应 Selector 的地址（指针）；返回的指针是 <code>Void *</code>，需要转换为对应的函数类型后才能使用。eg.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明函数类型：void (* methodType)(id, SEL, argType, ...) </span></span><br><span class="line"><span class="comment"> * void 是返回值类型，此处为空</span></span><br><span class="line"><span class="comment"> * id 和 SEL 是隐藏参数，此处需要显示传递</span></span><br><span class="line"><span class="comment"> * argType 是函数的实际参数类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (* test)(<span class="keyword">id</span>, SEL, <span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 将 void * 类型强转为对应函数类型</span></span><br><span class="line">test = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">int</span>))[<span class="keyword">self</span> methodForSelector:<span class="keyword">@selector</span>(print:)];</span><br><span class="line"><span class="comment">// 直接调用函数</span></span><br><span class="line">test(<span class="keyword">self</span>, <span class="keyword">@selector</span>(print:), <span class="number">999</span>);</span><br></pre></td></tr></table></figure><h4 id="消息查找的具体实现"><a href="#消息查找的具体实现" class="headerlink" title="消息查找的具体实现"></a>消息查找的具体实现</h4><p>消息查找是通过调用类中的<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>和<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>方法来分别查找类方法和对象方法</p><blockquote><p>可以在这两个方法中动态的添加一些原本没有的方法实现</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(dynamicMethodIMP)) &#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)dynamicMethodIMP, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> receiver, SEL _cmd, ...) &#123;</span><br><span class="line">    <span class="comment">// dynamic do somthing ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>在消息查找过程中，如果沿继承链最终依然没有找到对应的函数实现，消息就会进入转发流程，消息的转发分为两种情况：</p><ol><li>当前消息所属对象能够获取待转发的对象，此时直接返回该对象完成转发，如果无法获取则进入下一步骤</li><li>当前消息所属对象不能获取待转发的对象，此时需要将消息封装为函数签名，然后通过函数签名完成转发</li></ol><h4 id="可获取目标对象的转发"><a href="#可获取目标对象的转发" class="headerlink" title="可获取目标对象的转发"></a>可获取目标对象的转发</h4><p>消息转发首先检查是否有明确目标对象的转发，如果有则直接将消息发送到新的对象<br>该过程通过 <code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> 方法完成，该返回的实例对象就是新的消息对象，返回 <code>nil</code> 则继续进入下一步的转发</p><h4 id="无目标对象的转发（更加灵活）"><a href="#无目标对象的转发（更加灵活）" class="headerlink" title="无目标对象的转发（更加灵活）"></a>无目标对象的转发（更加灵活）</h4><p>如果当前消息所属对象无法获取消息转发的目标对象，则继续检查是否有对应的函数签名；如果有则通过函数签名调用将消息转发出去</p><ol><li>尝试通过 <code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code> 方法获取对应的函数签名</li><li>如果获取到对应的函数签名，则通过调用 <code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code> 方法转发消息</li></ol><blockquote><p>可以通过类方法<code>+ (NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector</code>获取类中对应的方法签名 （???消息转发过程中如果能直接获取到转发对象，是否也是通过此方法获取函数签名后完成的转发）</p></blockquote><h3 id="消息异常"><a href="#消息异常" class="headerlink" title="消息异常"></a>消息异常</h3><p>如果在消息无法处理并且转发失败之后，会抛出异常</p><blockquote><p>具体的实现机制是<code>NSObject</code>类中，<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>方法默认实现是调用 <code>doesNotRecognizeSelector:</code> 方法抛出异常</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Objective-C是C语言的严格超集－－任何C语言程序不经修改就可以直接通过Objective-C编译器，在Objective-C中使用C语言代码也是完全合法的。Objective-C的原意就是在C语言主体上加入面向对象的特性&lt;/p&gt;</summary>
    
    
    
    <category term="Cocoa" scheme="https://notes.honqi.ink/categories/cocoa/"/>
    
    <category term="ObjC" scheme="https://notes.honqi.ink/categories/cocoa/objc/"/>
    
    
  </entry>
  
</feed>
